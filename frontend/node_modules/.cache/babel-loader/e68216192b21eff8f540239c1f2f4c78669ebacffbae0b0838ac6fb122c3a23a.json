{"ast":null,"code":"/**\r\n * Enhanced IPFS utilities with local-only gateway usage\r\n */\n\n// Configuration\nconst IPFS_TIMEOUT = 30000; // 30 seconds\nconst MAX_RETRIES = 3;\nconst LOCAL_GATEWAY = 'http://127.0.0.1:8080/ipfs/';\nconst LOCAL_GATEWAYS = ['http://127.0.0.1:8080/ipfs/', 'http://localhost:8080/ipfs/'];\n\n/**\r\n * Normalizes an IPFS hash from various formats\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @returns {string} - The normalized hash string\r\n * @throws {Error} - If hash is invalid\r\n */\nexport const normalizeIpfsHash = hash => {\n  if (!hash) {\n    throw new Error('Empty IPFS hash provided');\n  }\n\n  // Extract hash from object if needed\n  if (typeof hash === 'object') {\n    hash = hash.cid || hash.Hash || hash.hash;\n  }\n\n  // Validate hash format\n  if (!hash || typeof hash !== 'string' || hash.length < 10) {\n    throw new Error(`Invalid IPFS hash format: ${hash}`);\n  }\n  return hash;\n};\n\n/**\r\n * Check if local gateway is accessible\r\n * @param {string} gateway - Gateway URL to check\r\n * @returns {Promise<boolean>} - True if gateway is accessible\r\n */\nconst isGatewayAccessible = async gateway => {\n  try {\n    const response = await fetch(`${gateway}QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/readme`, {\n      method: 'HEAD',\n      timeout: 5000\n    });\n    return response.ok;\n  } catch {\n    return false;\n  }\n};\n\n/**\r\n * Get the best available local gateway\r\n * @returns {Promise<string>} - Best available local gateway URL\r\n */\nconst getBestLocalGateway = async () => {\n  for (const gateway of LOCAL_GATEWAYS) {\n    if (await isGatewayAccessible(gateway)) {\n      return gateway;\n    }\n  }\n  return LOCAL_GATEWAY; // Default to primary local gateway\n};\n\n/**\r\n * Constructs a local IPFS URL for a given hash\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Options for URL construction\r\n * @param {boolean} [options.forceReload=false] - Whether to add cache-busting parameter\r\n * @returns {Promise<string>} - The complete local IPFS URL\r\n */\nexport const getIpfsUrl = async (hash, options = {}) => {\n  try {\n    const normalizedHash = normalizeIpfsHash(hash);\n    const gateway = await getBestLocalGateway();\n    const url = `${gateway}${normalizedHash}`;\n    return options.forceReload ? `${url}?t=${Date.now()}` : url;\n  } catch (error) {\n    console.error('Error constructing IPFS URL:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Check if an image is accessible with progressive loading support\r\n * @param {string} url - Image URL to check\r\n * @param {Object} options - Options for checking\r\n * @param {number} [options.timeout=5000] - Timeout in milliseconds\r\n * @param {Function} [options.onProgress] - Progress callback\r\n * @returns {Promise<boolean>} - True if image is accessible\r\n */\nexport const isImageAccessible = async (url, options = {}) => {\n  const {\n    timeout = 5000,\n    onProgress\n  } = options;\n  return new Promise(resolve => {\n    const img = new Image();\n    let timeoutId;\n    const cleanup = () => {\n      if (timeoutId) clearTimeout(timeoutId);\n      img.onload = img.onerror = null;\n    };\n    if (onProgress) {\n      img.onprogress = event => {\n        if (event.lengthComputable) {\n          onProgress(event.loaded / event.total);\n        }\n      };\n    }\n    img.onload = () => {\n      cleanup();\n      resolve(true);\n    };\n    img.onerror = () => {\n      cleanup();\n      resolve(false);\n    };\n    timeoutId = setTimeout(() => {\n      cleanup();\n      resolve(false);\n    }, timeout);\n    img.src = url;\n  });\n};\n\n/**\r\n * Get the best available local IPFS URL for an image with progressive loading\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Options for URL retrieval\r\n * @param {number} [options.maxRetries=3] - Maximum number of retries\r\n * @param {Function} [options.onProgress] - Progress callback\r\n * @returns {Promise<string>} - Best available local URL\r\n */\nexport const getBestIpfsUrl = async (hash, options = {}) => {\n  const {\n    maxRetries = MAX_RETRIES,\n    onProgress\n  } = options;\n  let lastError;\n  try {\n    const normalizedHash = normalizeIpfsHash(hash);\n\n    // Try each local gateway with retries\n    for (const gateway of LOCAL_GATEWAYS) {\n      for (let attempt = 0; attempt < maxRetries; attempt++) {\n        try {\n          const url = await getIpfsUrl(normalizedHash, {\n            gateway,\n            forceReload: attempt > 0\n          });\n          const isAccessible = await isImageAccessible(url, {\n            timeout: IPFS_TIMEOUT,\n            onProgress\n          });\n          if (isAccessible) {\n            return url;\n          }\n\n          // Wait before retry with exponential backoff\n          if (attempt < maxRetries - 1) {\n            await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\n          }\n        } catch (error) {\n          lastError = error;\n          console.warn(`Attempt ${attempt + 1} failed for gateway ${gateway}:`, error);\n        }\n      }\n    }\n    throw lastError || new Error('Failed to get accessible local IPFS URL');\n  } catch (error) {\n    console.error('Error getting best IPFS URL:', error);\n    throw error;\n  }\n};\n\n/**\r\n * Preload an IPFS image using local gateway\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Preload options\r\n * @returns {Promise<boolean>} - True if preload successful\r\n */\nexport const preloadIpfsImage = async (hash, options = {}) => {\n  try {\n    const url = await getBestIpfsUrl(hash, {\n      maxRetries: 5,\n      ...options\n    });\n    return await isImageAccessible(url, {\n      timeout: IPFS_TIMEOUT * 2,\n      ...options\n    });\n  } catch (error) {\n    console.error('Error preloading IPFS image:', error);\n    return false;\n  }\n};\n\n/**\r\n * Monitor local IPFS connection status\r\n * @returns {Promise<boolean>} - True if local IPFS is accessible\r\n */\nexport const checkIpfsConnection = async () => {\n  try {\n    const gateway = await getBestLocalGateway();\n    return Boolean(gateway);\n  } catch {\n    return false;\n  }\n};","map":{"version":3,"names":["IPFS_TIMEOUT","MAX_RETRIES","LOCAL_GATEWAY","LOCAL_GATEWAYS","normalizeIpfsHash","hash","Error","cid","Hash","length","isGatewayAccessible","gateway","response","fetch","method","timeout","ok","getBestLocalGateway","getIpfsUrl","options","normalizedHash","url","forceReload","Date","now","error","console","isImageAccessible","onProgress","Promise","resolve","img","Image","timeoutId","cleanup","clearTimeout","onload","onerror","onprogress","event","lengthComputable","loaded","total","setTimeout","src","getBestIpfsUrl","maxRetries","lastError","attempt","isAccessible","Math","pow","warn","preloadIpfsImage","checkIpfsConnection","Boolean"],"sources":["C:/Users/Erwachens/Desktop/MyProject/frontend/src/util/ipfs.js"],"sourcesContent":["/**\r\n * Enhanced IPFS utilities with local-only gateway usage\r\n */\r\n\r\n// Configuration\r\nconst IPFS_TIMEOUT = 30000; // 30 seconds\r\nconst MAX_RETRIES = 3;\r\nconst LOCAL_GATEWAY = 'http://127.0.0.1:8080/ipfs/';\r\nconst LOCAL_GATEWAYS = [\r\n  'http://127.0.0.1:8080/ipfs/',\r\n  'http://localhost:8080/ipfs/',\r\n];\r\n\r\n/**\r\n * Normalizes an IPFS hash from various formats\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @returns {string} - The normalized hash string\r\n * @throws {Error} - If hash is invalid\r\n */\r\nexport const normalizeIpfsHash = (hash) => {\r\n  if (!hash) {\r\n    throw new Error('Empty IPFS hash provided');\r\n  }\r\n  \r\n  // Extract hash from object if needed\r\n  if (typeof hash === 'object') {\r\n    hash = hash.cid || hash.Hash || hash.hash;\r\n  }\r\n  \r\n  // Validate hash format\r\n  if (!hash || typeof hash !== 'string' || hash.length < 10) {\r\n    throw new Error(`Invalid IPFS hash format: ${hash}`);\r\n  }\r\n  \r\n  return hash;\r\n};\r\n\r\n/**\r\n * Check if local gateway is accessible\r\n * @param {string} gateway - Gateway URL to check\r\n * @returns {Promise<boolean>} - True if gateway is accessible\r\n */\r\nconst isGatewayAccessible = async (gateway) => {\r\n  try {\r\n    const response = await fetch(`${gateway}QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/readme`, {\r\n      method: 'HEAD',\r\n      timeout: 5000\r\n    });\r\n    return response.ok;\r\n  } catch {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Get the best available local gateway\r\n * @returns {Promise<string>} - Best available local gateway URL\r\n */\r\nconst getBestLocalGateway = async () => {\r\n  for (const gateway of LOCAL_GATEWAYS) {\r\n    if (await isGatewayAccessible(gateway)) {\r\n      return gateway;\r\n    }\r\n  }\r\n  return LOCAL_GATEWAY; // Default to primary local gateway\r\n};\r\n\r\n/**\r\n * Constructs a local IPFS URL for a given hash\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Options for URL construction\r\n * @param {boolean} [options.forceReload=false] - Whether to add cache-busting parameter\r\n * @returns {Promise<string>} - The complete local IPFS URL\r\n */\r\nexport const getIpfsUrl = async (hash, options = {}) => {\r\n  try {\r\n    const normalizedHash = normalizeIpfsHash(hash);\r\n    const gateway = await getBestLocalGateway();\r\n    const url = `${gateway}${normalizedHash}`;\r\n    \r\n    return options.forceReload ? `${url}?t=${Date.now()}` : url;\r\n  } catch (error) {\r\n    console.error('Error constructing IPFS URL:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Check if an image is accessible with progressive loading support\r\n * @param {string} url - Image URL to check\r\n * @param {Object} options - Options for checking\r\n * @param {number} [options.timeout=5000] - Timeout in milliseconds\r\n * @param {Function} [options.onProgress] - Progress callback\r\n * @returns {Promise<boolean>} - True if image is accessible\r\n */\r\nexport const isImageAccessible = async (url, options = {}) => {\r\n  const { timeout = 5000, onProgress } = options;\r\n  \r\n  return new Promise((resolve) => {\r\n    const img = new Image();\r\n    let timeoutId;\r\n    \r\n    const cleanup = () => {\r\n      if (timeoutId) clearTimeout(timeoutId);\r\n      img.onload = img.onerror = null;\r\n    };\r\n    \r\n    if (onProgress) {\r\n      img.onprogress = (event) => {\r\n        if (event.lengthComputable) {\r\n          onProgress(event.loaded / event.total);\r\n        }\r\n      };\r\n    }\r\n    \r\n    img.onload = () => {\r\n      cleanup();\r\n      resolve(true);\r\n    };\r\n    \r\n    img.onerror = () => {\r\n      cleanup();\r\n      resolve(false);\r\n    };\r\n    \r\n    timeoutId = setTimeout(() => {\r\n      cleanup();\r\n      resolve(false);\r\n    }, timeout);\r\n    \r\n    img.src = url;\r\n  });\r\n};\r\n\r\n/**\r\n * Get the best available local IPFS URL for an image with progressive loading\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Options for URL retrieval\r\n * @param {number} [options.maxRetries=3] - Maximum number of retries\r\n * @param {Function} [options.onProgress] - Progress callback\r\n * @returns {Promise<string>} - Best available local URL\r\n */\r\nexport const getBestIpfsUrl = async (hash, options = {}) => {\r\n  const { maxRetries = MAX_RETRIES, onProgress } = options;\r\n  let lastError;\r\n  \r\n  try {\r\n    const normalizedHash = normalizeIpfsHash(hash);\r\n    \r\n    // Try each local gateway with retries\r\n    for (const gateway of LOCAL_GATEWAYS) {\r\n      for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n        try {\r\n          const url = await getIpfsUrl(normalizedHash, {\r\n            gateway,\r\n            forceReload: attempt > 0\r\n          });\r\n          \r\n          const isAccessible = await isImageAccessible(url, {\r\n            timeout: IPFS_TIMEOUT,\r\n            onProgress\r\n          });\r\n          \r\n          if (isAccessible) {\r\n            return url;\r\n          }\r\n          \r\n          // Wait before retry with exponential backoff\r\n          if (attempt < maxRetries - 1) {\r\n            await new Promise(resolve => \r\n              setTimeout(resolve, Math.pow(2, attempt) * 1000)\r\n            );\r\n          }\r\n        } catch (error) {\r\n          lastError = error;\r\n          console.warn(`Attempt ${attempt + 1} failed for gateway ${gateway}:`, error);\r\n        }\r\n      }\r\n    }\r\n    \r\n    throw lastError || new Error('Failed to get accessible local IPFS URL');\r\n  } catch (error) {\r\n    console.error('Error getting best IPFS URL:', error);\r\n    throw error;\r\n  }\r\n};\r\n\r\n/**\r\n * Preload an IPFS image using local gateway\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Preload options\r\n * @returns {Promise<boolean>} - True if preload successful\r\n */\r\nexport const preloadIpfsImage = async (hash, options = {}) => {\r\n  try {\r\n    const url = await getBestIpfsUrl(hash, {\r\n      maxRetries: 5,\r\n      ...options\r\n    });\r\n    \r\n    return await isImageAccessible(url, {\r\n      timeout: IPFS_TIMEOUT * 2,\r\n      ...options\r\n    });\r\n  } catch (error) {\r\n    console.error('Error preloading IPFS image:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Monitor local IPFS connection status\r\n * @returns {Promise<boolean>} - True if local IPFS is accessible\r\n */\r\nexport const checkIpfsConnection = async () => {\r\n  try {\r\n    const gateway = await getBestLocalGateway();\r\n    return Boolean(gateway);\r\n  } catch {\r\n    return false;\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}