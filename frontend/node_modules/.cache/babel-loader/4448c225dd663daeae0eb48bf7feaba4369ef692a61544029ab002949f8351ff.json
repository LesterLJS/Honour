{"ast":null,"code":"/**\r\n * Normalizes an IPFS hash from various formats\r\n * @param {string|object} hash - The IPFS hash/CID which might be a string or object\r\n * @returns {string} - The normalized hash string\r\n */\nexport const normalizeIpfsHash = hash => {\n  if (!hash) return '';\n\n  // If hash is an object, extract the CID\n  if (typeof hash === 'object') {\n    return hash.cid || hash.Hash || hash.hash || '';\n  }\n\n  // Otherwise return the hash string\n  return String(hash);\n};\n\n/**\r\n * Constructs a consistent IPFS URL for a given hash\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {boolean} forceReload - Whether to add a timestamp to force reload\r\n * @returns {string} - The complete IPFS URL\r\n */\nexport const getIpfsUrl = (hash, forceReload = false) => {\n  const normalizedHash = normalizeIpfsHash(hash);\n  if (!normalizedHash) return '';\n\n  // Always use local gateway as per requirements\n  const gateway = 'http://127.0.0.1:8080/ipfs/';\n  const url = `${gateway}${normalizedHash}`;\n\n  // Add timestamp to force reload if requested\n  return forceReload ? `${url}?t=${Date.now()}` : url;\n};\n\n/**\r\n * Get alternative IPFS URLs for a given hash\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @returns {Array} - Array of IPFS URLs using different gateways\r\n */\nexport const getAlternativeIpfsUrls = hash => {\n  const normalizedHash = normalizeIpfsHash(hash);\n  if (!normalizedHash) return [];\n\n  // Return array of URLs with local gateway first\n  return [`http://127.0.0.1:8080/ipfs/${normalizedHash}`];\n};\n\n/**\r\n * Checks if an image URL is accessible\r\n * @param {string} url - The URL to check\r\n * @param {number} timeout - Timeout in milliseconds\r\n * @returns {Promise<boolean>} - Promise resolving to true if accessible, false otherwise\r\n */\nexport const isImageAccessible = (url, timeout = 5000) => {\n  return new Promise(resolve => {\n    const img = new Image();\n    img.onload = () => resolve(true);\n    img.onerror = () => resolve(false);\n\n    // Set a timeout to resolve false if the image takes too long to load\n    const timeoutId = setTimeout(() => resolve(false), timeout);\n\n    // Clear timeout if image loads or errors\n    img.onload = () => {\n      clearTimeout(timeoutId);\n      resolve(true);\n    };\n    img.onerror = () => {\n      clearTimeout(timeoutId);\n      resolve(false);\n    };\n    img.src = url;\n  });\n};\n\n/**\r\n * Get the best available IPFS URL for an image\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {number} maxRetries - Maximum number of retries with force reload\r\n * @returns {Promise<string>} - Promise resolving to the best available URL\r\n */\nexport const getBestIpfsUrl = async (hash, maxRetries = 5) => {\n  const normalizedHash = normalizeIpfsHash(hash);\n  if (!normalizedHash) return '';\n\n  // Try the local gateway first\n  const localUrl = getIpfsUrl(normalizedHash);\n\n  // Check if the image is accessible\n  let isAccessible = await isImageAccessible(localUrl);\n\n  // If not accessible, try with force reload a few times\n  if (!isAccessible) {\n    for (let i = 0; i < maxRetries; i++) {\n      console.log(`Retrying IPFS image load (${i + 1}/${maxRetries}): ${normalizedHash}`);\n      const retryUrl = getIpfsUrl(normalizedHash, true);\n      isAccessible = await isImageAccessible(retryUrl);\n      if (isAccessible) {\n        return retryUrl;\n      }\n      // Exponential backoff: wait longer between retries\n      const waitTime = 1000 * Math.pow(2, i);\n      console.log(`Waiting ${waitTime}ms before next retry`);\n      await new Promise(resolve => setTimeout(resolve, waitTime));\n    }\n  }\n\n  // Return the local URL even if not accessible\n  return localUrl;\n};\n\n/**\r\n * Preload an IPFS image to ensure it's in the browser cache\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @returns {Promise<boolean>} - Promise resolving to true if preloaded successfully\r\n */\nexport const preloadIpfsImage = async hash => {\n  // Try to get the best URL with more retries for preloading\n  const url = await getBestIpfsUrl(hash, 7);\n  return isImageAccessible(url, 15000); // Longer timeout for preloading\n};","map":{"version":3,"names":["normalizeIpfsHash","hash","cid","Hash","String","getIpfsUrl","forceReload","normalizedHash","gateway","url","Date","now","getAlternativeIpfsUrls","isImageAccessible","timeout","Promise","resolve","img","Image","onload","onerror","timeoutId","setTimeout","clearTimeout","src","getBestIpfsUrl","maxRetries","localUrl","isAccessible","i","console","log","retryUrl","waitTime","Math","pow","preloadIpfsImage"],"sources":["C:/Users/Erwachens/Desktop/MyProject/frontend/src/util/ipfs.js"],"sourcesContent":["/**\r\n * Normalizes an IPFS hash from various formats\r\n * @param {string|object} hash - The IPFS hash/CID which might be a string or object\r\n * @returns {string} - The normalized hash string\r\n */\r\nexport const normalizeIpfsHash = (hash) => {\r\n  if (!hash) return '';\r\n  \r\n  // If hash is an object, extract the CID\r\n  if (typeof hash === 'object') {\r\n    return hash.cid || hash.Hash || hash.hash || '';\r\n  }\r\n  \r\n  // Otherwise return the hash string\r\n  return String(hash);\r\n};\r\n\r\n/**\r\n * Constructs a consistent IPFS URL for a given hash\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {boolean} forceReload - Whether to add a timestamp to force reload\r\n * @returns {string} - The complete IPFS URL\r\n */\r\nexport const getIpfsUrl = (hash, forceReload = false) => {\r\n  const normalizedHash = normalizeIpfsHash(hash);\r\n  if (!normalizedHash) return '';\r\n  \r\n  // Always use local gateway as per requirements\r\n  const gateway = 'http://127.0.0.1:8080/ipfs/';\r\n  const url = `${gateway}${normalizedHash}`;\r\n  \r\n  // Add timestamp to force reload if requested\r\n  return forceReload ? `${url}?t=${Date.now()}` : url;\r\n};\r\n\r\n/**\r\n * Get alternative IPFS URLs for a given hash\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @returns {Array} - Array of IPFS URLs using different gateways\r\n */\r\nexport const getAlternativeIpfsUrls = (hash) => {\r\n  const normalizedHash = normalizeIpfsHash(hash);\r\n  if (!normalizedHash) return [];\r\n  \r\n  // Return array of URLs with local gateway first\r\n  return [\r\n    `http://127.0.0.1:8080/ipfs/${normalizedHash}`\r\n  ];\r\n};\r\n\r\n/**\r\n * Checks if an image URL is accessible\r\n * @param {string} url - The URL to check\r\n * @param {number} timeout - Timeout in milliseconds\r\n * @returns {Promise<boolean>} - Promise resolving to true if accessible, false otherwise\r\n */\r\nexport const isImageAccessible = (url, timeout = 5000) => {\r\n  return new Promise((resolve) => {\r\n    const img = new Image();\r\n    img.onload = () => resolve(true);\r\n    img.onerror = () => resolve(false);\r\n    \r\n    // Set a timeout to resolve false if the image takes too long to load\r\n    const timeoutId = setTimeout(() => resolve(false), timeout);\r\n    \r\n    // Clear timeout if image loads or errors\r\n    img.onload = () => {\r\n      clearTimeout(timeoutId);\r\n      resolve(true);\r\n    };\r\n    \r\n    img.onerror = () => {\r\n      clearTimeout(timeoutId);\r\n      resolve(false);\r\n    };\r\n    \r\n    img.src = url;\r\n  });\r\n};\r\n\r\n/**\r\n * Get the best available IPFS URL for an image\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {number} maxRetries - Maximum number of retries with force reload\r\n * @returns {Promise<string>} - Promise resolving to the best available URL\r\n */\r\nexport const getBestIpfsUrl = async (hash, maxRetries = 5) => {\r\n  const normalizedHash = normalizeIpfsHash(hash);\r\n  if (!normalizedHash) return '';\r\n  \r\n  // Try the local gateway first\r\n  const localUrl = getIpfsUrl(normalizedHash);\r\n  \r\n  // Check if the image is accessible\r\n  let isAccessible = await isImageAccessible(localUrl);\r\n  \r\n  // If not accessible, try with force reload a few times\r\n  if (!isAccessible) {\r\n    for (let i = 0; i < maxRetries; i++) {\r\n      console.log(`Retrying IPFS image load (${i+1}/${maxRetries}): ${normalizedHash}`);\r\n      const retryUrl = getIpfsUrl(normalizedHash, true);\r\n      isAccessible = await isImageAccessible(retryUrl);\r\n      if (isAccessible) {\r\n        return retryUrl;\r\n      }\r\n      // Exponential backoff: wait longer between retries\r\n      const waitTime = 1000 * Math.pow(2, i);\r\n      console.log(`Waiting ${waitTime}ms before next retry`);\r\n      await new Promise(resolve => setTimeout(resolve, waitTime));\r\n    }\r\n  }\r\n  \r\n  // Return the local URL even if not accessible\r\n  return localUrl;\r\n};\r\n\r\n/**\r\n * Preload an IPFS image to ensure it's in the browser cache\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @returns {Promise<boolean>} - Promise resolving to true if preloaded successfully\r\n */\r\nexport const preloadIpfsImage = async (hash) => {\r\n  // Try to get the best URL with more retries for preloading\r\n  const url = await getBestIpfsUrl(hash, 7);\r\n  return isImageAccessible(url, 15000); // Longer timeout for preloading\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}