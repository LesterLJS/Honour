{"ast":null,"code":"/**\r\n * Enhanced IPFS utilities with local-only gateway usage\r\n */\n\n// Configuration\nconst IPFS_TIMEOUT = 30000; // 30 seconds\nconst MAX_RETRIES = 3;\nconst LOCAL_GATEWAY = 'http://127.0.0.1:8080/ipfs/';\nconst LOCAL_GATEWAYS = ['http://127.0.0.1:8080/ipfs/', 'http://localhost:8080/ipfs/'];\n\n/**\r\n * Normalizes an IPFS hash from various formats\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @returns {string} - The normalized hash string\r\n * @throws {Error} - If hash is invalid\r\n */\nexport const normalizeIpfsHash = hash => {\n  if (!hash) {\n    console.warn('Empty IPFS hash provided');\n    return null;\n  }\n\n  // Extract hash from object if needed\n  if (typeof hash === 'object') {\n    hash = hash.cid || hash.Hash || hash.hash || hash.ipfs_hash;\n  }\n\n  // Handle string that might be JSON\n  if (typeof hash === 'string' && hash.startsWith('{')) {\n    try {\n      const parsed = JSON.parse(hash);\n      hash = parsed.cid || parsed.Hash || parsed.hash || parsed.ipfs_hash;\n    } catch (e) {\n      // If parsing fails, use the string as-is\n      console.warn('Failed to parse IPFS hash JSON:', e);\n    }\n  }\n\n  // Validate hash format\n  if (!hash || typeof hash !== 'string' || hash.length < 10) {\n    console.warn(`Invalid IPFS hash format: ${hash}`);\n    return null;\n  }\n  return hash;\n};\n\n/**\r\n * Check if local gateway is accessible\r\n * @param {string} gateway - Gateway URL to check\r\n * @returns {Promise<boolean>} - True if gateway is accessible\r\n */\nconst isGatewayAccessible = async gateway => {\n  try {\n    const response = await fetch(`${gateway}QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/readme`, {\n      method: 'HEAD',\n      timeout: 5000\n    });\n    return response.ok;\n  } catch {\n    return false;\n  }\n};\n\n/**\r\n * Get the best available local gateway\r\n * @returns {Promise<string>} - Best available local gateway URL\r\n */\nconst getBestLocalGateway = async () => {\n  for (const gateway of LOCAL_GATEWAYS) {\n    if (await isGatewayAccessible(gateway)) {\n      return gateway;\n    }\n  }\n  return LOCAL_GATEWAY; // Default to primary local gateway\n};\n\n/**\r\n * Constructs a local IPFS URL for a given hash\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {boolean} [forceReload=false] - Whether to add cache-busting parameter\r\n * @returns {string} - The complete local IPFS URL\r\n */\nexport const getIpfsUrl = (hash, forceReload = false) => {\n  try {\n    const normalizedHash = normalizeIpfsHash(hash);\n    if (!normalizedHash) {\n      return 'https://via.placeholder.com/300x200?text=Invalid+IPFS+Hash';\n    }\n\n    // Use the first gateway by default without async check\n    const gateway = LOCAL_GATEWAY;\n    const url = `${gateway}${normalizedHash}`;\n    return forceReload ? `${url}?t=${Date.now()}` : url;\n  } catch (error) {\n    console.error('Error constructing IPFS URL:', error);\n    return 'https://via.placeholder.com/300x200?text=Error+Loading+Image';\n  }\n};\n\n/**\r\n * Constructs a local IPFS URL for a given hash with gateway check\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Options for URL construction\r\n * @param {boolean} [options.forceReload=false] - Whether to add cache-busting parameter\r\n * @returns {Promise<string>} - The complete local IPFS URL\r\n */\nexport const getIpfsUrlAsync = async (hash, options = {}) => {\n  try {\n    const normalizedHash = normalizeIpfsHash(hash);\n    if (!normalizedHash) {\n      return 'https://via.placeholder.com/300x200?text=Invalid+IPFS+Hash';\n    }\n    const gateway = await getBestLocalGateway();\n    const url = `${gateway}${normalizedHash}`;\n    return options.forceReload ? `${url}?t=${Date.now()}` : url;\n  } catch (error) {\n    console.error('Error constructing IPFS URL:', error);\n    return 'https://via.placeholder.com/300x200?text=Error+Loading+Image';\n  }\n};\n\n/**\r\n * Check if an image is accessible with progressive loading support\r\n * @param {string} url - Image URL to check\r\n * @param {Object} options - Options for checking\r\n * @param {number} [options.timeout=5000] - Timeout in milliseconds\r\n * @param {Function} [options.onProgress] - Progress callback\r\n * @returns {Promise<boolean>} - True if image is accessible\r\n */\nexport const isImageAccessible = async (url, options = {}) => {\n  const {\n    timeout = 5000,\n    onProgress\n  } = options;\n  return new Promise(resolve => {\n    const img = new Image();\n    let timeoutId;\n    const cleanup = () => {\n      if (timeoutId) clearTimeout(timeoutId);\n      img.onload = img.onerror = null;\n    };\n    if (onProgress) {\n      img.onprogress = event => {\n        if (event.lengthComputable) {\n          onProgress(event.loaded / event.total);\n        }\n      };\n    }\n    img.onload = () => {\n      cleanup();\n      resolve(true);\n    };\n    img.onerror = () => {\n      cleanup();\n      resolve(false);\n    };\n    timeoutId = setTimeout(() => {\n      cleanup();\n      resolve(false);\n    }, timeout);\n    img.src = url;\n  });\n};\n\n/**\r\n * Get the best available local IPFS URL for an image with progressive loading\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {number|Object} maxRetriesOrOptions - Maximum number of retries or options object\r\n * @param {Function} [onProgress] - Progress callback (deprecated, use options.onProgress)\r\n * @returns {Promise<string>} - Best available local URL\r\n */\nexport const getBestIpfsUrl = async (hash, maxRetriesOrOptions = MAX_RETRIES, onProgress) => {\n  // Handle different parameter formats for backward compatibility\n  let options = {};\n  if (typeof maxRetriesOrOptions === 'number') {\n    options = {\n      maxRetries: maxRetriesOrOptions,\n      onProgress\n    };\n  } else if (typeof maxRetriesOrOptions === 'object') {\n    options = maxRetriesOrOptions;\n  }\n  const {\n    maxRetries = MAX_RETRIES,\n    onProgress: progressCallback = onProgress\n  } = options;\n  let lastError;\n  try {\n    const normalizedHash = normalizeIpfsHash(hash);\n    if (!normalizedHash) {\n      return 'https://via.placeholder.com/300x200?text=Invalid+IPFS+Hash';\n    }\n\n    // First try the synchronous method which is faster\n    const quickUrl = getIpfsUrl(normalizedHash, false);\n\n    // Quick check if the image is already accessible\n    try {\n      const isQuickAccessible = await isImageAccessible(quickUrl, {\n        timeout: 3000,\n        // Short timeout for quick check\n        onProgress: progressCallback\n      });\n      if (isQuickAccessible) {\n        return quickUrl;\n      }\n    } catch (e) {\n      // Ignore error and continue with full retry logic\n    }\n\n    // Try each local gateway with retries\n    for (const gateway of LOCAL_GATEWAYS) {\n      for (let attempt = 0; attempt < maxRetries; attempt++) {\n        try {\n          // Add cache-busting parameter for retries\n          const url = `${gateway}${normalizedHash}${attempt > 0 ? `?t=${Date.now()}` : ''}`;\n          const isAccessible = await isImageAccessible(url, {\n            timeout: Math.min(IPFS_TIMEOUT, 5000 + attempt * 2000),\n            // Increase timeout with each attempt\n            onProgress: progressCallback\n          });\n          if (isAccessible) {\n            return url;\n          }\n\n          // Wait before retry with exponential backoff\n          if (attempt < maxRetries - 1) {\n            await new Promise(resolve => setTimeout(resolve, Math.min(Math.pow(2, attempt) * 500, 5000)));\n          }\n        } catch (error) {\n          lastError = error;\n          console.warn(`Attempt ${attempt + 1} failed for gateway ${gateway}:`, error);\n        }\n      }\n    }\n\n    // If all attempts failed, return the default URL as a last resort\n    console.error('Failed to get accessible local IPFS URL:', lastError);\n    return `${LOCAL_GATEWAY}${normalizedHash}?fallback=true`;\n  } catch (error) {\n    console.error('Error getting best IPFS URL:', error);\n    return 'https://via.placeholder.com/300x200?text=Error+Loading+Image';\n  }\n};\n\n/**\r\n * Preload an IPFS image using local gateway\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Preload options\r\n * @returns {Promise<boolean>} - True if preload successful\r\n */\nexport const preloadIpfsImage = async (hash, options = {}) => {\n  try {\n    const url = await getBestIpfsUrl(hash, {\n      maxRetries: 5,\n      ...options\n    });\n\n    // If we got a placeholder URL, preload failed\n    if (url.includes('placeholder.com')) {\n      console.warn('Preload failed, got placeholder URL');\n      return false;\n    }\n    return await isImageAccessible(url, {\n      timeout: IPFS_TIMEOUT * 2,\n      ...options\n    });\n  } catch (error) {\n    console.error('Error preloading IPFS image:', error);\n    return false;\n  }\n};\n\n/**\r\n * Monitor local IPFS connection status\r\n * @returns {Promise<boolean>} - True if local IPFS is accessible\r\n */\nexport const checkIpfsConnection = async () => {\n  try {\n    const gateway = await getBestLocalGateway();\n    return Boolean(gateway);\n  } catch {\n    return false;\n  }\n};","map":{"version":3,"names":["IPFS_TIMEOUT","MAX_RETRIES","LOCAL_GATEWAY","LOCAL_GATEWAYS","normalizeIpfsHash","hash","console","warn","cid","Hash","ipfs_hash","startsWith","parsed","JSON","parse","e","length","isGatewayAccessible","gateway","response","fetch","method","timeout","ok","getBestLocalGateway","getIpfsUrl","forceReload","normalizedHash","url","Date","now","error","getIpfsUrlAsync","options","isImageAccessible","onProgress","Promise","resolve","img","Image","timeoutId","cleanup","clearTimeout","onload","onerror","onprogress","event","lengthComputable","loaded","total","setTimeout","src","getBestIpfsUrl","maxRetriesOrOptions","maxRetries","progressCallback","lastError","quickUrl","isQuickAccessible","attempt","isAccessible","Math","min","pow","preloadIpfsImage","includes","checkIpfsConnection","Boolean"],"sources":["C:/Users/Erwachens/Desktop/MyProject/frontend/src/util/ipfs.js"],"sourcesContent":["/**\r\n * Enhanced IPFS utilities with local-only gateway usage\r\n */\r\n\r\n// Configuration\r\nconst IPFS_TIMEOUT = 30000; // 30 seconds\r\nconst MAX_RETRIES = 3;\r\nconst LOCAL_GATEWAY = 'http://127.0.0.1:8080/ipfs/';\r\nconst LOCAL_GATEWAYS = [\r\n  'http://127.0.0.1:8080/ipfs/',\r\n  'http://localhost:8080/ipfs/',\r\n];\r\n\r\n/**\r\n * Normalizes an IPFS hash from various formats\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @returns {string} - The normalized hash string\r\n * @throws {Error} - If hash is invalid\r\n */\r\nexport const normalizeIpfsHash = (hash) => {\r\n  if (!hash) {\r\n    console.warn('Empty IPFS hash provided');\r\n    return null;\r\n  }\r\n  \r\n  // Extract hash from object if needed\r\n  if (typeof hash === 'object') {\r\n    hash = hash.cid || hash.Hash || hash.hash || hash.ipfs_hash;\r\n  }\r\n  \r\n  // Handle string that might be JSON\r\n  if (typeof hash === 'string' && hash.startsWith('{')) {\r\n    try {\r\n      const parsed = JSON.parse(hash);\r\n      hash = parsed.cid || parsed.Hash || parsed.hash || parsed.ipfs_hash;\r\n    } catch (e) {\r\n      // If parsing fails, use the string as-is\r\n      console.warn('Failed to parse IPFS hash JSON:', e);\r\n    }\r\n  }\r\n  \r\n  // Validate hash format\r\n  if (!hash || typeof hash !== 'string' || hash.length < 10) {\r\n    console.warn(`Invalid IPFS hash format: ${hash}`);\r\n    return null;\r\n  }\r\n  \r\n  return hash;\r\n};\r\n\r\n/**\r\n * Check if local gateway is accessible\r\n * @param {string} gateway - Gateway URL to check\r\n * @returns {Promise<boolean>} - True if gateway is accessible\r\n */\r\nconst isGatewayAccessible = async (gateway) => {\r\n  try {\r\n    const response = await fetch(`${gateway}QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/readme`, {\r\n      method: 'HEAD',\r\n      timeout: 5000\r\n    });\r\n    return response.ok;\r\n  } catch {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Get the best available local gateway\r\n * @returns {Promise<string>} - Best available local gateway URL\r\n */\r\nconst getBestLocalGateway = async () => {\r\n  for (const gateway of LOCAL_GATEWAYS) {\r\n    if (await isGatewayAccessible(gateway)) {\r\n      return gateway;\r\n    }\r\n  }\r\n  return LOCAL_GATEWAY; // Default to primary local gateway\r\n};\r\n\r\n/**\r\n * Constructs a local IPFS URL for a given hash\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {boolean} [forceReload=false] - Whether to add cache-busting parameter\r\n * @returns {string} - The complete local IPFS URL\r\n */\r\nexport const getIpfsUrl = (hash, forceReload = false) => {\r\n  try {\r\n    const normalizedHash = normalizeIpfsHash(hash);\r\n    if (!normalizedHash) {\r\n      return 'https://via.placeholder.com/300x200?text=Invalid+IPFS+Hash';\r\n    }\r\n    \r\n    // Use the first gateway by default without async check\r\n    const gateway = LOCAL_GATEWAY;\r\n    const url = `${gateway}${normalizedHash}`;\r\n    \r\n    return forceReload ? `${url}?t=${Date.now()}` : url;\r\n  } catch (error) {\r\n    console.error('Error constructing IPFS URL:', error);\r\n    return 'https://via.placeholder.com/300x200?text=Error+Loading+Image';\r\n  }\r\n};\r\n\r\n/**\r\n * Constructs a local IPFS URL for a given hash with gateway check\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Options for URL construction\r\n * @param {boolean} [options.forceReload=false] - Whether to add cache-busting parameter\r\n * @returns {Promise<string>} - The complete local IPFS URL\r\n */\r\nexport const getIpfsUrlAsync = async (hash, options = {}) => {\r\n  try {\r\n    const normalizedHash = normalizeIpfsHash(hash);\r\n    if (!normalizedHash) {\r\n      return 'https://via.placeholder.com/300x200?text=Invalid+IPFS+Hash';\r\n    }\r\n    \r\n    const gateway = await getBestLocalGateway();\r\n    const url = `${gateway}${normalizedHash}`;\r\n    \r\n    return options.forceReload ? `${url}?t=${Date.now()}` : url;\r\n  } catch (error) {\r\n    console.error('Error constructing IPFS URL:', error);\r\n    return 'https://via.placeholder.com/300x200?text=Error+Loading+Image';\r\n  }\r\n};\r\n\r\n/**\r\n * Check if an image is accessible with progressive loading support\r\n * @param {string} url - Image URL to check\r\n * @param {Object} options - Options for checking\r\n * @param {number} [options.timeout=5000] - Timeout in milliseconds\r\n * @param {Function} [options.onProgress] - Progress callback\r\n * @returns {Promise<boolean>} - True if image is accessible\r\n */\r\nexport const isImageAccessible = async (url, options = {}) => {\r\n  const { timeout = 5000, onProgress } = options;\r\n  \r\n  return new Promise((resolve) => {\r\n    const img = new Image();\r\n    let timeoutId;\r\n    \r\n    const cleanup = () => {\r\n      if (timeoutId) clearTimeout(timeoutId);\r\n      img.onload = img.onerror = null;\r\n    };\r\n    \r\n    if (onProgress) {\r\n      img.onprogress = (event) => {\r\n        if (event.lengthComputable) {\r\n          onProgress(event.loaded / event.total);\r\n        }\r\n      };\r\n    }\r\n    \r\n    img.onload = () => {\r\n      cleanup();\r\n      resolve(true);\r\n    };\r\n    \r\n    img.onerror = () => {\r\n      cleanup();\r\n      resolve(false);\r\n    };\r\n    \r\n    timeoutId = setTimeout(() => {\r\n      cleanup();\r\n      resolve(false);\r\n    }, timeout);\r\n    \r\n    img.src = url;\r\n  });\r\n};\r\n\r\n/**\r\n * Get the best available local IPFS URL for an image with progressive loading\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {number|Object} maxRetriesOrOptions - Maximum number of retries or options object\r\n * @param {Function} [onProgress] - Progress callback (deprecated, use options.onProgress)\r\n * @returns {Promise<string>} - Best available local URL\r\n */\r\nexport const getBestIpfsUrl = async (hash, maxRetriesOrOptions = MAX_RETRIES, onProgress) => {\r\n  // Handle different parameter formats for backward compatibility\r\n  let options = {};\r\n  if (typeof maxRetriesOrOptions === 'number') {\r\n    options = { maxRetries: maxRetriesOrOptions, onProgress };\r\n  } else if (typeof maxRetriesOrOptions === 'object') {\r\n    options = maxRetriesOrOptions;\r\n  }\r\n  \r\n  const { maxRetries = MAX_RETRIES, onProgress: progressCallback = onProgress } = options;\r\n  let lastError;\r\n  \r\n  try {\r\n    const normalizedHash = normalizeIpfsHash(hash);\r\n    if (!normalizedHash) {\r\n      return 'https://via.placeholder.com/300x200?text=Invalid+IPFS+Hash';\r\n    }\r\n    \r\n    // First try the synchronous method which is faster\r\n    const quickUrl = getIpfsUrl(normalizedHash, false);\r\n    \r\n    // Quick check if the image is already accessible\r\n    try {\r\n      const isQuickAccessible = await isImageAccessible(quickUrl, {\r\n        timeout: 3000, // Short timeout for quick check\r\n        onProgress: progressCallback\r\n      });\r\n      \r\n      if (isQuickAccessible) {\r\n        return quickUrl;\r\n      }\r\n    } catch (e) {\r\n      // Ignore error and continue with full retry logic\r\n    }\r\n    \r\n    // Try each local gateway with retries\r\n    for (const gateway of LOCAL_GATEWAYS) {\r\n      for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n        try {\r\n          // Add cache-busting parameter for retries\r\n          const url = `${gateway}${normalizedHash}${attempt > 0 ? `?t=${Date.now()}` : ''}`;\r\n          \r\n          const isAccessible = await isImageAccessible(url, {\r\n            timeout: Math.min(IPFS_TIMEOUT, 5000 + (attempt * 2000)), // Increase timeout with each attempt\r\n            onProgress: progressCallback\r\n          });\r\n          \r\n          if (isAccessible) {\r\n            return url;\r\n          }\r\n          \r\n          // Wait before retry with exponential backoff\r\n          if (attempt < maxRetries - 1) {\r\n            await new Promise(resolve => \r\n              setTimeout(resolve, Math.min(Math.pow(2, attempt) * 500, 5000))\r\n            );\r\n          }\r\n        } catch (error) {\r\n          lastError = error;\r\n          console.warn(`Attempt ${attempt + 1} failed for gateway ${gateway}:`, error);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // If all attempts failed, return the default URL as a last resort\r\n    console.error('Failed to get accessible local IPFS URL:', lastError);\r\n    return `${LOCAL_GATEWAY}${normalizedHash}?fallback=true`;\r\n  } catch (error) {\r\n    console.error('Error getting best IPFS URL:', error);\r\n    return 'https://via.placeholder.com/300x200?text=Error+Loading+Image';\r\n  }\r\n};\r\n\r\n/**\r\n * Preload an IPFS image using local gateway\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Preload options\r\n * @returns {Promise<boolean>} - True if preload successful\r\n */\r\nexport const preloadIpfsImage = async (hash, options = {}) => {\r\n  try {\r\n    const url = await getBestIpfsUrl(hash, {\r\n      maxRetries: 5,\r\n      ...options\r\n    });\r\n    \r\n    // If we got a placeholder URL, preload failed\r\n    if (url.includes('placeholder.com')) {\r\n      console.warn('Preload failed, got placeholder URL');\r\n      return false;\r\n    }\r\n    \r\n    return await isImageAccessible(url, {\r\n      timeout: IPFS_TIMEOUT * 2,\r\n      ...options\r\n    });\r\n  } catch (error) {\r\n    console.error('Error preloading IPFS image:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Monitor local IPFS connection status\r\n * @returns {Promise<boolean>} - True if local IPFS is accessible\r\n */\r\nexport const checkIpfsConnection = async () => {\r\n  try {\r\n    const gateway = await getBestLocalGateway();\r\n    return Boolean(gateway);\r\n  } catch {\r\n    return false;\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}