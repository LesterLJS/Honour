{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Erwachens\\\\Desktop\\\\MyProject\\\\frontend\\\\src\\\\context\\\\ImageContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useCallback, useRef } from 'react';\nimport { uploadImage as apiUploadImage, getMyImages as apiGetMyImages, getImageDownloadLink as apiGetImageDownloadLink, downloadImageFile as apiDownloadImageFile, getAllImages as apiGetAllImages, deleteImage as apiDeleteImage } from '../api/images';\nimport { normalizeIpfsHash } from '../util/ipfs';\n\n// Create the context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ImageContext = /*#__PURE__*/createContext(null);\n\n// Custom hook to use the image context\nexport const useImages = () => {\n  _s();\n  return useContext(ImageContext);\n};\n_s(useImages, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const ImageProvider = ({\n  children\n}) => {\n  _s2();\n  const [myImages, setMyImages] = useState([]);\n  const [allImages, setAllImages] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [pagination, setPagination] = useState({\n    currentPage: 1,\n    totalPages: 1,\n    totalImages: 0,\n    pageSize: 9,\n    hasNext: false,\n    hasPrevious: false\n  });\n\n  // Cache for API requests\n  const requestCache = useRef({\n    myImages: {},\n    // Cache for getMyImages requests\n    downloadLinks: {},\n    // Cache for getImageDownloadLink requests\n    cacheTimeout: 30000,\n    // Cache timeout in ms (30 seconds)\n\n    // Get cached data if available and not expired\n    get(cacheKey, type) {\n      const cache = this[type];\n      const cachedData = cache[cacheKey];\n      if (cachedData && Date.now() - cachedData.timestamp < this.cacheTimeout) {\n        console.log(`Using cached data for ${type} - ${cacheKey}`);\n        return cachedData.data;\n      }\n      return null;\n    },\n    // Store data in cache\n    set(cacheKey, data, type) {\n      this[type][cacheKey] = {\n        data,\n        timestamp: Date.now()\n      };\n    },\n    // Clear specific cache entry\n    clear(cacheKey, type) {\n      if (this[type][cacheKey]) {\n        delete this[type][cacheKey];\n      }\n    },\n    // Clear all cache\n    clearAll() {\n      this.myImages = {};\n      this.downloadLinks = {};\n    }\n  });\n\n  // Upload an image\n  const uploadImage = useCallback(async imageFile => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiUploadImage(imageFile);\n      // Add the new image to the myImages array\n      setMyImages(prevImages => [response.data, ...prevImages]);\n      return response.data;\n    } catch (err) {\n      var _err$response, _err$response$data;\n      setError(((_err$response = err.response) === null || _err$response === void 0 ? void 0 : (_err$response$data = _err$response.data) === null || _err$response$data === void 0 ? void 0 : _err$response$data.error) || 'Image upload failed');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Get user's images with pagination\n  const getMyImages = useCallback(async (page = 1, pageSize = 9) => {\n    // Create a cache key based on pagination parameters\n    const cacheKey = `page_${page}_size_${pageSize}`;\n\n    // Check if we have cached data\n    const cachedData = requestCache.current.get(cacheKey, 'myImages');\n    if (cachedData) {\n      // Use cached data without making a new request\n      setMyImages(cachedData.results);\n      setPagination({\n        currentPage: cachedData.pagination.current_page,\n        totalPages: cachedData.pagination.total_pages,\n        totalImages: cachedData.pagination.total_images,\n        pageSize: cachedData.pagination.page_size,\n        hasNext: cachedData.pagination.has_next,\n        hasPrevious: cachedData.pagination.has_previous\n      });\n      return cachedData;\n    }\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiGetMyImages({\n        page,\n        page_size: pageSize\n      });\n\n      // The response now contains both results and pagination info\n      const {\n        results,\n        pagination: paginationData\n      } = response.data;\n\n      // Update state with the images and pagination info\n      setMyImages(results);\n      setPagination({\n        currentPage: paginationData.current_page,\n        totalPages: paginationData.total_pages,\n        totalImages: paginationData.total_images,\n        pageSize: paginationData.page_size,\n        hasNext: paginationData.has_next,\n        hasPrevious: paginationData.has_previous\n      });\n\n      // Cache the response data\n      requestCache.current.set(cacheKey, response.data, 'myImages');\n      return response.data;\n    } catch (err) {\n      var _err$response2, _err$response2$data;\n      setError(((_err$response2 = err.response) === null || _err$response2 === void 0 ? void 0 : (_err$response2$data = _err$response2.data) === null || _err$response2$data === void 0 ? void 0 : _err$response2$data.error) || 'Failed to fetch images');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Navigate to next page\n  const nextPage = useCallback(() => {\n    if (pagination.hasNext) {\n      getMyImages(pagination.currentPage + 1, pagination.pageSize);\n    }\n  }, [pagination]);\n\n  // Navigate to previous page\n  const previousPage = useCallback(() => {\n    if (pagination.hasPrevious) {\n      getMyImages(pagination.currentPage - 1, pagination.pageSize);\n    }\n  }, [pagination]);\n\n  // Go to a specific page\n  const goToPage = useCallback(page => {\n    if (page >= 1 && page <= pagination.totalPages) {\n      getMyImages(page, pagination.pageSize);\n    }\n  }, [pagination]);\n\n  // Get IPFS download link with direct cached image URL\n  const getImageDownloadLink = useCallback(async _ipfs_hash => {\n    // Check if we have cached data for this image\n    const cacheKey = `image_${normalizeIpfsHash}`;\n    const cachedData = requestCache.current.get(cacheKey, 'downloadLinks');\n    if (cachedData) {\n      // Use cached data without making a new request\n      return cachedData;\n    }\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiGetImageDownloadLink(_ipfs_hash);\n\n      // Add a direct cached image URL that uses the backend's caching system\n      // This URL will be served from the server's cache if available\n      if (response.data) {\n        // Create a direct URL to the cached image without cache busting parameter\n        // to allow browser caching and prevent request loops\n        const cachedImageUrl = `/api/images/download-file/${_ipfs_hash}/`;\n        response.data.cachedImageUrl = cachedImageUrl;\n      }\n\n      // Cache the response data\n      requestCache.current.set(cacheKey, response, 'downloadLinks');\n\n      // Return the full response with all URLs and blockchain data\n      return response;\n    } catch (err) {\n      var _err$response3, _err$response3$data;\n      setError(((_err$response3 = err.response) === null || _err$response3 === void 0 ? void 0 : (_err$response3$data = _err$response3.data) === null || _err$response3$data === void 0 ? void 0 : _err$response3$data.error) || 'Failed to get download link');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Get a stable image URL that won't change between renders\n  const getImageUrl = useCallback(normalizeIpfsHash => {\n    // Create a URL without timestamp to allow browser caching\n    return `/api/images/download-file/${_ipfs_hash}/`;\n  }, []);\n\n  // Directly download image file from IPFS through the backend\n  const downloadImageFile = useCallback(async _ipfs_hash => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiDownloadImageFile(_ipfs_hash);\n\n      // If we got a blob response, create an object URL for it\n      if (response.blob) {\n        const objectUrl = URL.createObjectURL(response.blob);\n        return {\n          success: true,\n          objectUrl,\n          contentType: response.contentType,\n          blob: response.blob\n        };\n      }\n      // If we got a URL fallback\n      else if (response.url) {\n        return {\n          success: true,\n          url: response.url,\n          hash: response.hash\n        };\n      }\n      // If we got an error\n      else {\n        setError(response.error || 'Failed to download image');\n        return {\n          success: false,\n          error: response.error || 'Failed to download image'\n        };\n      }\n    } catch (err) {\n      var _err$response4, _err$response4$data;\n      const errorMsg = ((_err$response4 = err.response) === null || _err$response4 === void 0 ? void 0 : (_err$response4$data = _err$response4.data) === null || _err$response4$data === void 0 ? void 0 : _err$response4$data.error) || 'Failed to download image';\n      setError(errorMsg);\n      return {\n        success: false,\n        error: errorMsg\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Admin: Get all images\n  const getAllImages = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiGetAllImages();\n      setAllImages(response.data);\n      return response.data;\n    } catch (err) {\n      var _err$response5, _err$response5$data;\n      setError(((_err$response5 = err.response) === null || _err$response5 === void 0 ? void 0 : (_err$response5$data = _err$response5.data) === null || _err$response5$data === void 0 ? void 0 : _err$response5$data.error) || 'Failed to fetch all images');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []); // Add comma here\n\n  // Admin: Delete an image\n  const deleteImage = useCallback(async normalizeIpfsHash => {\n    setLoading(true);\n    setError(null);\n    try {\n      await apiDeleteImage(normalizeIpfsHash);\n      // Remove the deleted image from state\n      setAllImages(prevImages => prevImages.filter(img => img.id !== normalizeIpfsHash));\n      setMyImages(prevImages => prevImages.filter(img => img.id !== normalizeIpfsHash));\n      return true;\n    } catch (err) {\n      var _err$response6, _err$response6$data;\n      setError(((_err$response6 = err.response) === null || _err$response6 === void 0 ? void 0 : (_err$response6$data = _err$response6.data) === null || _err$response6$data === void 0 ? void 0 : _err$response6$data.error) || 'Failed to delete image');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []); // Add comma here\n\n  // Context value\n  const value = {\n    myImages,\n    allImages,\n    loading,\n    error,\n    pagination,\n    uploadImage,\n    getMyImages,\n    getImageDownloadLink,\n    downloadImageFile,\n    getImageUrl,\n    getAllImages,\n    deleteImage,\n    nextPage,\n    previousPage,\n    goToPage\n  };\n  return /*#__PURE__*/_jsxDEV(ImageContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 314,\n    columnNumber: 10\n  }, this);\n};\n_s2(ImageProvider, \"aFbvo1dI9aMs6VyhJkLG9ta453w=\");\n_c = ImageProvider;\nexport default ImageContext;\nvar _c;\n$RefreshReg$(_c, \"ImageProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useCallback","useRef","uploadImage","apiUploadImage","getMyImages","apiGetMyImages","getImageDownloadLink","apiGetImageDownloadLink","downloadImageFile","apiDownloadImageFile","getAllImages","apiGetAllImages","deleteImage","apiDeleteImage","normalizeIpfsHash","jsxDEV","_jsxDEV","ImageContext","useImages","_s","ImageProvider","children","_s2","myImages","setMyImages","allImages","setAllImages","loading","setLoading","error","setError","pagination","setPagination","currentPage","totalPages","totalImages","pageSize","hasNext","hasPrevious","requestCache","downloadLinks","cacheTimeout","get","cacheKey","type","cache","cachedData","Date","now","timestamp","console","log","data","set","clear","clearAll","imageFile","response","prevImages","err","_err$response","_err$response$data","page","current","results","current_page","total_pages","total_images","page_size","has_next","has_previous","paginationData","_err$response2","_err$response2$data","nextPage","previousPage","goToPage","_ipfs_hash","cachedImageUrl","_err$response3","_err$response3$data","getImageUrl","blob","objectUrl","URL","createObjectURL","success","contentType","url","hash","_err$response4","_err$response4$data","errorMsg","_err$response5","_err$response5$data","filter","img","id","_err$response6","_err$response6$data","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Erwachens/Desktop/MyProject/frontend/src/context/ImageContext.jsx"],"sourcesContent":["import React, { createContext, useState, useContext, useCallback, useRef } from 'react';\r\nimport { \r\n  uploadImage as apiUploadImage,\r\n  getMyImages as apiGetMyImages,\r\n  getImageDownloadLink as apiGetImageDownloadLink,\r\n  downloadImageFile as apiDownloadImageFile,\r\n\r\n\r\n  getAllImages as apiGetAllImages,\r\n  deleteImage as apiDeleteImage,\r\n\r\n} from '../api/images';\r\nimport { normalizeIpfsHash } from '../util/ipfs';\r\n\r\n// Create the context\r\nconst ImageContext = createContext(null);\r\n\r\n// Custom hook to use the image context\r\nexport const useImages = () => useContext(ImageContext);\r\n\r\nexport const ImageProvider = ({ children }) => {\r\n  const [myImages, setMyImages] = useState([]);\r\n  const [allImages, setAllImages] = useState([]);\r\n\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n  const [pagination, setPagination] = useState({\r\n    currentPage: 1,\r\n    totalPages: 1,\r\n    totalImages: 0,\r\n    pageSize: 9,\r\n    hasNext: false,\r\n    hasPrevious: false\r\n  });\r\n  \r\n  // Cache for API requests\r\n  const requestCache = useRef({\r\n    myImages: {}, // Cache for getMyImages requests\r\n    downloadLinks: {}, // Cache for getImageDownloadLink requests\r\n    cacheTimeout: 30000, // Cache timeout in ms (30 seconds)\r\n    \r\n    // Get cached data if available and not expired\r\n    get(cacheKey, type) {\r\n      const cache = this[type];\r\n      const cachedData = cache[cacheKey];\r\n      \r\n      if (cachedData && Date.now() - cachedData.timestamp < this.cacheTimeout) {\r\n        console.log(`Using cached data for ${type} - ${cacheKey}`);\r\n        return cachedData.data;\r\n      }\r\n      \r\n      return null;\r\n    },\r\n    \r\n    // Store data in cache\r\n    set(cacheKey, data, type) {\r\n      this[type][cacheKey] = {\r\n        data,\r\n        timestamp: Date.now()\r\n      };\r\n    },\r\n    \r\n    // Clear specific cache entry\r\n    clear(cacheKey, type) {\r\n      if (this[type][cacheKey]) {\r\n        delete this[type][cacheKey];\r\n      }\r\n    },\r\n    \r\n    // Clear all cache\r\n    clearAll() {\r\n      this.myImages = {};\r\n      this.downloadLinks = {};\r\n    }\r\n  });\r\n\r\n  // Upload an image\r\n  const uploadImage = useCallback(async (imageFile) => {\r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      const response = await apiUploadImage(imageFile);\r\n      // Add the new image to the myImages array\r\n      setMyImages(prevImages => [response.data, ...prevImages]);\r\n      return response.data;\r\n    } catch (err) {\r\n      setError(err.response?.data?.error || 'Image upload failed');\r\n      throw err;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, []);\r\n\r\n\r\n  // Get user's images with pagination\r\n  const getMyImages = useCallback(async (page = 1, pageSize = 9) => {\r\n    // Create a cache key based on pagination parameters\r\n    const cacheKey = `page_${page}_size_${pageSize}`;\r\n    \r\n    // Check if we have cached data\r\n    const cachedData = requestCache.current.get(cacheKey, 'myImages');\r\n    if (cachedData) {\r\n      // Use cached data without making a new request\r\n      setMyImages(cachedData.results);\r\n      setPagination({\r\n        currentPage: cachedData.pagination.current_page,\r\n        totalPages: cachedData.pagination.total_pages,\r\n        totalImages: cachedData.pagination.total_images,\r\n        pageSize: cachedData.pagination.page_size,\r\n        hasNext: cachedData.pagination.has_next,\r\n        hasPrevious: cachedData.pagination.has_previous\r\n      });\r\n      return cachedData;\r\n    }\r\n    \r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      const response = await apiGetMyImages({ page, page_size: pageSize });\r\n      \r\n      // The response now contains both results and pagination info\r\n      const { results, pagination: paginationData } = response.data;\r\n      \r\n      // Update state with the images and pagination info\r\n      setMyImages(results);\r\n      setPagination({\r\n        currentPage: paginationData.current_page,\r\n        totalPages: paginationData.total_pages,\r\n        totalImages: paginationData.total_images,\r\n        pageSize: paginationData.page_size,\r\n        hasNext: paginationData.has_next,\r\n        hasPrevious: paginationData.has_previous\r\n      });\r\n      \r\n      // Cache the response data\r\n      requestCache.current.set(cacheKey, response.data, 'myImages');\r\n      \r\n      return response.data;\r\n    } catch (err) {\r\n      setError(err.response?.data?.error || 'Failed to fetch images');\r\n      throw err;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, []);\r\n  \r\n  // Navigate to next page\r\n  const nextPage = useCallback(() => {\r\n    if (pagination.hasNext) {\r\n      getMyImages(pagination.currentPage + 1, pagination.pageSize);\r\n    }\r\n  }, [pagination]);\r\n\r\n  // Navigate to previous page\r\n  const previousPage = useCallback(() => {\r\n    if (pagination.hasPrevious) {\r\n      getMyImages(pagination.currentPage - 1, pagination.pageSize);\r\n    }\r\n  }, [pagination]);\r\n\r\n  // Go to a specific page\r\n  const goToPage = useCallback((page) => {\r\n    if (page >= 1 && page <= pagination.totalPages) {\r\n      getMyImages(page, pagination.pageSize);\r\n    }\r\n  }, [pagination]);\r\n\r\n// Get IPFS download link with direct cached image URL\r\nconst getImageDownloadLink = useCallback(async (_ipfs_hash) => {\r\n  // Check if we have cached data for this image\r\n  const cacheKey = `image_${normalizeIpfsHash}`;\r\n  const cachedData = requestCache.current.get(cacheKey, 'downloadLinks');\r\n  if (cachedData) {\r\n    // Use cached data without making a new request\r\n    return cachedData;\r\n  }\r\n  \r\n  setLoading(true);\r\n  setError(null);\r\n  try {\r\n    const response = await apiGetImageDownloadLink(_ipfs_hash);\r\n    \r\n    // Add a direct cached image URL that uses the backend's caching system\r\n    // This URL will be served from the server's cache if available\r\n    if (response.data) {\r\n      // Create a direct URL to the cached image without cache busting parameter\r\n      // to allow browser caching and prevent request loops\r\n      const cachedImageUrl = `/api/images/download-file/${_ipfs_hash}/`;\r\n      response.data.cachedImageUrl = cachedImageUrl;\r\n    }\r\n    \r\n    // Cache the response data\r\n    requestCache.current.set(cacheKey, response, 'downloadLinks');\r\n    \r\n    // Return the full response with all URLs and blockchain data\r\n    return response;\r\n  } catch (err) {\r\n    setError(err.response?.data?.error || 'Failed to get download link');\r\n    throw err;\r\n  } finally {\r\n    setLoading(false);\r\n  }\r\n}, []);\r\n\r\n// Get a stable image URL that won't change between renders\r\nconst getImageUrl = useCallback((normalizeIpfsHash) => {\r\n  // Create a URL without timestamp to allow browser caching\r\n  return `/api/images/download-file/${_ipfs_hash}/`;\r\n}, []);\r\n\r\n// Directly download image file from IPFS through the backend\r\nconst downloadImageFile = useCallback(async (_ipfs_hash) => {\r\n  setLoading(true);\r\n  setError(null);\r\n  try {\r\n    const response = await apiDownloadImageFile(_ipfs_hash);\r\n    \r\n    // If we got a blob response, create an object URL for it\r\n    if (response.blob) {\r\n      const objectUrl = URL.createObjectURL(response.blob);\r\n      return {\r\n        success: true,\r\n        objectUrl,\r\n        contentType: response.contentType,\r\n        blob: response.blob\r\n      };\r\n    } \r\n    // If we got a URL fallback\r\n    else if (response.url) {\r\n      return {\r\n        success: true,\r\n        url: response.url,\r\n        hash: response.hash\r\n      };\r\n    }\r\n    // If we got an error\r\n    else {\r\n      setError(response.error || 'Failed to download image');\r\n      return {\r\n        success: false,\r\n        error: response.error || 'Failed to download image'\r\n      };\r\n    }\r\n  } catch (err) {\r\n    const errorMsg = err.response?.data?.error || 'Failed to download image';\r\n    setError(errorMsg);\r\n    return {\r\n      success: false,\r\n      error: errorMsg\r\n    };\r\n  } finally {\r\n    setLoading(false);\r\n  }\r\n}, []);\r\n\r\n  \r\n// Admin: Get all images\r\nconst getAllImages = useCallback(async () => {\r\n  setLoading(true);\r\n  setError(null);\r\n  try {\r\n    const response = await apiGetAllImages();\r\n    setAllImages(response.data);\r\n    return response.data;\r\n  } catch (err) {\r\n    setError(err.response?.data?.error || 'Failed to fetch all images');\r\n    throw err;\r\n  } finally {\r\n    setLoading(false);\r\n  }\r\n}, []); // Add comma here\r\n\r\n// Admin: Delete an image\r\nconst deleteImage = useCallback(async (normalizeIpfsHash) => {\r\n  setLoading(true);\r\n  setError(null);\r\n  try {\r\n    await apiDeleteImage(normalizeIpfsHash);\r\n    // Remove the deleted image from state\r\n    setAllImages(prevImages => prevImages.filter(img => img.id !== normalizeIpfsHash));\r\n    setMyImages(prevImages => prevImages.filter(img => img.id !== normalizeIpfsHash));\r\n    return true;\r\n  } catch (err) {\r\n    setError(err.response?.data?.error || 'Failed to delete image');\r\n    throw err;\r\n  } finally {\r\n    setLoading(false);\r\n  }\r\n}, []); // Add comma here\r\n\r\n  \r\n  // Context value\r\n  const value = {\r\n    myImages,\r\n    allImages,\r\n    loading,\r\n    error,\r\n    pagination,\r\n    uploadImage,\r\n    \r\n    getMyImages,\r\n    getImageDownloadLink,\r\n    downloadImageFile,\r\n    getImageUrl,\r\n   \r\n    getAllImages,\r\n    deleteImage,\r\n    \r\n    nextPage,\r\n    previousPage,\r\n    goToPage,\r\n  };\r\n\r\n  return <ImageContext.Provider value={value}>{children}</ImageContext.Provider>;\r\n};\r\n\r\nexport default ImageContext;\r\n\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}