{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Erwachens\\\\Desktop\\\\MyProject\\\\frontend\\\\src\\\\pages\\\\Dashboard.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState, useCallback, useMemo } from 'react';\nimport { Link } from 'react-router-dom';\nimport { useAuth } from '../context/AuthContext';\nimport { useImages } from '../context/ImageContext';\nimport Navbar from '../components/common/Navbar';\nimport { normalizeIpfsHash } from '../util/ipfs';\n\n// Local IPFS gateway URL\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst LOCAL_GATEWAY = 'http://127.0.0.1:8080/ipfs/';\n\n// Function to get IPFS URL from hash\nconst getIpfsUrl = hash => {\n  const normalizedHash = normalizeIpfsHash(hash);\n  if (!normalizedHash) return '';\n  return `${LOCAL_GATEWAY}${normalizedHash}`;\n};\nconst Dashboard = () => {\n  _s();\n  const {\n    user\n  } = useAuth();\n  const {\n    myImages,\n    loading,\n    error,\n    pagination,\n    getMyImages,\n    getImageDownloadLink,\n    downloadImageFile,\n    nextPage,\n    previousPage,\n    goToPage\n  } = useImages();\n\n  // Add state to track loading status of individual images\n  const [imageLoadingStates, setImageLoadingStates] = useState({});\n\n  // Enhanced queue for limiting concurrent API requests with retry and backoff\n  const requestQueue = React.useRef({\n    queue: [],\n    running: 0,\n    maxConcurrent: 2,\n    // Limit to 2 concurrent requests\n    maxRetries: 3,\n    // Maximum number of retries per request\n    abortControllers: new Map(),\n    // Track abort controllers for each request\n\n    add(fn, priority = false, retryCount = 0, id = Date.now().toString()) {\n      // Skip adding if component is unmounted\n      if (!isMounted.current) return;\n      const queueItem = {\n        fn,\n        retryCount,\n        id\n      };\n\n      // Create an AbortController for this request\n      const controller = new AbortController();\n      this.abortControllers.set(id, controller);\n\n      // Add high priority items to the front of the queue\n      if (priority) {\n        this.queue.unshift(queueItem);\n      } else {\n        this.queue.push(queueItem);\n      }\n      this.processQueue();\n\n      // Return the request ID so it can be aborted later if needed\n      return id;\n    },\n    async processQueue() {\n      if (this.running >= this.maxConcurrent || this.queue.length === 0 || !isMounted.current) {\n        return;\n      }\n      this.running++;\n      const {\n        fn,\n        retryCount,\n        id\n      } = this.queue.shift();\n\n      // Skip if component is unmounted or this specific request was aborted\n      if (!isMounted.current || this.abortControllers.has(id) && this.abortControllers.get(id).signal.aborted) {\n        this.running--;\n        this.abortControllers.delete(id);\n        this.processQueue();\n        return;\n      }\n      try {\n        // Get the abort controller for this request\n        const controller = this.abortControllers.get(id);\n\n        // Pass the abort signal to the function if it accepts it\n        await fn(controller === null || controller === void 0 ? void 0 : controller.signal);\n      } catch (error) {\n        // Check if the error is due to abortion\n        if (error.name === 'AbortError') {\n          console.log(`Request ${id} was aborted`);\n        } else {\n          console.error(\"Error in queue processing:\", error);\n\n          // Only retry if the component is still mounted and we haven't exceeded max retries\n          if (isMounted.current && retryCount < this.maxRetries) {\n            console.log(`Retrying request (attempt ${retryCount + 1} of ${this.maxRetries})...`);\n\n            // Calculate backoff delay: 2^retryCount * 1000ms (1s, 2s, 4s, etc.)\n            const backoffDelay = Math.min(Math.pow(2, retryCount) * 1000, 10000);\n            setTimeout(() => {\n              if (isMounted.current) {\n                // Re-add the failed request to the queue with increased retry count\n                this.add(fn, false, retryCount + 1, id);\n              }\n            }, backoffDelay);\n          }\n        }\n      } finally {\n        this.running--;\n        this.abortControllers.delete(id);\n\n        // Only continue processing if component is still mounted\n        if (isMounted.current) {\n          // Add a small delay between requests to prevent overwhelming the server\n          setTimeout(() => {\n            this.processQueue();\n          }, 100);\n        }\n      }\n    },\n    // Abort a specific request\n    abort(id) {\n      if (this.abortControllers.has(id)) {\n        this.abortControllers.get(id).abort();\n        this.abortControllers.delete(id);\n      }\n    },\n    // Clear the queue and abort all pending requests\n    clear() {\n      // Abort all pending requests\n      this.abortControllers.forEach(controller => {\n        try {\n          controller.abort();\n        } catch (e) {\n          console.error(\"Error aborting request:\", e);\n        }\n      });\n      this.queue = [];\n      this.abortControllers.clear();\n    }\n  });\n\n  // Reference to track if the component is mounted\n  const isMounted = React.useRef(true);\n\n  // Clear the request queue when component unmounts\n  useEffect(() => {\n    // Store a reference to the current queue for cleanup\n    const currentQueue = requestQueue.current;\n    return () => {\n      isMounted.current = false;\n      currentQueue.clear();\n    };\n  }, []);\n\n  // Create a memoized version of the preload function to avoid recreating it on every render\n  const preloadImage = useCallback(async (image, abortSignal) => {\n    if (!isMounted.current) return;\n    setImageLoadingStates(prev => ({\n      ...prev,\n      [image.id]: true\n    }));\n    try {\n      // Create a timeout promise that rejects after a certain time\n      const timeoutPromise = new Promise((_, reject) => {\n        const id = setTimeout(() => {\n          clearTimeout(id);\n          reject(new Error(`Preload timeout for image ${image.id}`));\n        }, 15000); // 15 second timeout\n      });\n\n      // Race the actual request against the timeout\n      await Promise.race([getImageDownloadLink(image.id), timeoutPromise]);\n\n      // Check if component is still mounted or if the request was aborted\n      if (!isMounted.current || abortSignal && abortSignal.aborted) return;\n      console.log(`Preloaded image ${image.id}`);\n    } catch (err) {\n      // Check if component is still mounted or if the request was aborted\n      if (!isMounted.current || abortSignal && abortSignal.aborted) return;\n\n      // Check if it's an abort error\n      if (err.name === 'AbortError') {\n        console.log(`Preload aborted for image ${image.id}`);\n      } else {\n        console.error(`Failed to preload image ${image.id}:`, err);\n      }\n    } finally {\n      // Only update state if component is still mounted and request wasn't aborted\n      if (isMounted.current && !(abortSignal && abortSignal.aborted)) {\n        setImageLoadingStates(prev => ({\n          ...prev,\n          [image.id]: false\n        }));\n      }\n    }\n  }, [getImageDownloadLink]);\n\n  // Track if initial load has happened\n  const initialLoadRef = React.useRef(false);\n\n  // Fetch user's images when component mounts or pagination changes\n  useEffect(() => {\n    // Skip if this is just a re-render and not a pagination change\n    if (initialLoadRef.current && pagination.currentPage === 1 && pagination.pageSize === 9 && myImages.length > 0) {\n      return;\n    }\n\n    // Set initial load flag\n    initialLoadRef.current = true;\n\n    // Create an AbortController for this effect\n    const controller = new AbortController();\n    const {\n      signal\n    } = controller;\n\n    // Use a debounce mechanism to prevent multiple rapid calls\n    const timeoutId = setTimeout(async () => {\n      if (!isMounted.current || signal.aborted) return;\n      try {\n        // Load the current page of images with abort signal\n        const response = await getMyImages(pagination.currentPage, pagination.pageSize);\n        if (!isMounted.current || signal.aborted) return;\n        const images = response.results || [];\n        console.log(`Loaded ${images.length} images for page ${pagination.currentPage}`);\n\n        // Create a Set to track which images we've already started preloading\n        const preloadedImages = new Set();\n\n        // Store request IDs for cleanup\n        const requestIds = [];\n\n        // Preload images sequentially using the request queue to limit concurrent requests\n        // Only preload visible images to reduce unnecessary requests\n        images.forEach(image => {\n          if (!isMounted.current || signal.aborted) return;\n\n          // Skip if we've already started preloading this image\n          if (preloadedImages.has(image.id)) {\n            return;\n          }\n\n          // Mark this image as being preloaded\n          preloadedImages.add(image.id);\n\n          // Add to queue and store request ID\n          const requestId = requestQueue.current.add(async abortSignal => {\n            await preloadImage(image, abortSignal);\n          });\n          if (requestId) {\n            requestIds.push(requestId);\n          }\n        });\n\n        // Add cleanup for these specific requests\n        signal.addEventListener('abort', () => {\n          requestIds.forEach(id => requestQueue.current.abort(id));\n        });\n      } catch (err) {\n        if (!isMounted.current || signal.aborted) return;\n        if (err.name === 'AbortError') {\n          console.log('Image loading aborted');\n        } else {\n          console.error('Failed to load images:', err);\n        }\n      }\n    }, 300); // 300ms debounce delay\n\n    // Cleanup function to cancel any pending operations if the dependencies change\n    return () => {\n      clearTimeout(timeoutId);\n      controller.abort();\n    };\n  }, [pagination.currentPage, pagination.pageSize, getMyImages, preloadImage, myImages.length]);\n\n  // eslint-disable-next-line no-unused-vars\n  const handleDownload = async imageId => {\n    try {\n      // First try the direct download method\n      console.log(`Attempting direct download for image ${imageId}`);\n      setImageLoadingStates(prev => ({\n        ...prev,\n        [imageId]: true\n      }));\n      const directResult = await downloadImageFile(imageId);\n      if (directResult.success) {\n        console.log(`Direct download successful for image ${imageId}`);\n\n        // If we got an objectUrl (blob), create a download link\n        if (directResult.objectUrl) {\n          // Create a temporary anchor element to trigger download\n          const link = document.createElement('a');\n          link.href = directResult.objectUrl;\n          link.setAttribute('download', `image-${imageId}.jpg`);\n          document.body.appendChild(link);\n          link.click();\n          document.body.removeChild(link);\n\n          // Clean up the object URL to avoid memory leaks\n          setTimeout(() => URL.revokeObjectURL(directResult.objectUrl), 100);\n          console.log(`Download initiated for image ${imageId} using blob`);\n        }\n        // If we got a fallback URL, open it in a new tab\n        else if (directResult.url) {\n          window.open(directResult.url, '_blank');\n          console.log(`Download initiated for image ${imageId} using fallback URL`);\n        }\n      } else {\n        // If direct download failed, fall back to the old method\n        console.log(`Direct download failed for image ${imageId}, falling back to link method`);\n        const response = await getImageDownloadLink(imageId);\n        console.log(`Download link response for image ${imageId}:`, response);\n\n        // Get the image from our state\n        const image = myImages.find(img => img.id === imageId);\n        if (!image) {\n          console.error(`Image ${imageId} not found in state`);\n          return;\n        }\n\n        // Get the best available URL (local or public)\n        let downloadUrl;\n        if (response.data && response.data.ipfsUrls && response.data.ipfsUrls.local) {\n          downloadUrl = response.data.ipfsUrls.local;\n          console.log(`Using local URL from response: ${downloadUrl}`);\n        } else if (response.data && response.data.ipfsUrl) {\n          // Fallback to the original URL if the new structure isn't available\n          downloadUrl = response.data.ipfsUrl;\n          console.log(`Using original URL from response: ${downloadUrl}`);\n        } else {\n          // If no URL is available, construct one from the hash using our utility\n          const hash = response.data && response.data.ipfsHash || image.ipfs_hash;\n          const normalizedHash = normalizeIpfsHash(hash);\n          downloadUrl = normalizedHash ? `${LOCAL_GATEWAY}${normalizedHash}` : '';\n          console.log(`Constructed URL from hash: ${downloadUrl}`);\n        }\n\n        // Create a temporary anchor element to trigger download\n        const link = document.createElement('a');\n        link.href = downloadUrl;\n        link.setAttribute('download', `image-${imageId}.jpg`);\n        link.setAttribute('target', '_blank');\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        console.log(`Download initiated for image ${imageId} using fallback method`);\n      }\n    } catch (err) {\n      console.error('Failed to download image:', err);\n      alert('Failed to download image. Please try again later.');\n    } finally {\n      setImageLoadingStates(prev => ({\n        ...prev,\n        [imageId]: false\n      }));\n    }\n  };\n\n  // Memoize the refresh image handler to prevent recreation on each render\n  const handleRefreshImage = useCallback(async image => {\n    // Skip if component is unmounted\n    if (!isMounted.current) return;\n\n    // Set loading state\n    setImageLoadingStates(prev => ({\n      ...prev,\n      [image.id]: true\n    }));\n\n    // Create an AbortController for this operation\n    const controller = new AbortController();\n    const {\n      signal\n    } = controller;\n\n    // Set a timeout to abort the request if it takes too long\n    const timeoutId = setTimeout(() => {\n      controller.abort();\n      console.log(`Refresh timeout for image ${image.id}`);\n\n      // Reset loading state if component is still mounted\n      if (isMounted.current) {\n        setImageLoadingStates(prev => ({\n          ...prev,\n          [image.id]: false\n        }));\n      }\n    }, 10000); // 10 second timeout\n\n    try {\n      // Attempt to refresh the image by getting a new download link\n      await getImageDownloadLink(image.id);\n\n      // Skip further processing if component unmounted or request was aborted\n      if (!isMounted.current || signal.aborted) return;\n      console.log(`Successfully refreshed image ${image.id}`);\n\n      // Force reload the image by updating its src\n      const imgElement = document.getElementById(`img-${image.id}`);\n      if (imgElement) {\n        const currentSrc = imgElement.src;\n        imgElement.src = '';\n        // Add a cache-busting parameter\n        imgElement.src = `${currentSrc}${currentSrc.includes('?') ? '&' : '?'}t=${Date.now()}`;\n      }\n    } catch (err) {\n      // Skip error handling if component unmounted or request was aborted\n      if (!isMounted.current || signal.aborted) return;\n      if (err.name === 'AbortError') {\n        console.log(`Refresh aborted for image ${image.id}`);\n      } else {\n        console.error(`Error refreshing image ${image.id}:`, err);\n      }\n    } finally {\n      // Clear the timeout\n      clearTimeout(timeoutId);\n\n      // Only update state if component is still mounted and request wasn't aborted\n      if (isMounted.current && !signal.aborted) {\n        setImageLoadingStates(prev => ({\n          ...prev,\n          [image.id]: false\n        }));\n      }\n    }\n  }, [getImageDownloadLink]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(Navbar, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 439,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"container\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"card\",\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          children: [\"Welcome, \", user === null || user === void 0 ? void 0 : user.username, \"!\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 443,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: [\"Role: \", user === null || user === void 0 ? void 0 : user.role]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 444,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            marginTop: '20px'\n          },\n          children: [/*#__PURE__*/_jsxDEV(Link, {\n            to: \"/upload\",\n            className: \"btn\",\n            children: \"Upload New Image\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 447,\n            columnNumber: 13\n          }, this), (user === null || user === void 0 ? void 0 : user.role) === 'admin' && /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 446,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 442,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n        style: {\n          marginTop: '30px'\n        },\n        children: \"My Images\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 458,\n        columnNumber: 9\n      }, this), loading && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"spinner\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 461,\n        columnNumber: 11\n      }, this), error && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"alert alert-danger\",\n        children: error\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 465,\n        columnNumber: 11\n      }, this), !loading && myImages.length === 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"card\",\n        children: /*#__PURE__*/_jsxDEV(\"p\", {\n          children: \"You haven't uploaded any images yet.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 470,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 469,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"image-grid\",\n        style: {\n          marginBottom: '20px'\n        },\n        children: myImages.map(image => /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"image-card\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              position: 'relative'\n            },\n            children: [imageLoadingStates[image.id] ? /*#__PURE__*/_jsxDEV(\"div\", {\n              style: {\n                width: '100%',\n                height: '200px',\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center',\n                backgroundColor: '#f0f0f0',\n                borderTopLeftRadius: '8px',\n                borderTopRightRadius: '8px'\n              },\n              children: /*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"spinner\",\n                style: {\n                  width: '40px',\n                  height: '40px'\n                }\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 491,\n                columnNumber: 21\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 479,\n              columnNumber: 19\n            }, this) : /*#__PURE__*/_jsxDEV(\"img\", {\n              id: `img-${image.id}`,\n              src: getIpfsUrl(image.ipfs_hash),\n              alt: `ID: ${image.id}`,\n              style: {\n                width: '100%',\n                height: '200px',\n                objectFit: 'cover',\n                borderTopLeftRadius: '8px',\n                borderTopRightRadius: '8px'\n              },\n              onError: e => {\n                console.log(`Image ${image.id} failed to load, attempting to recover...`);\n\n                // Skip if component is unmounted\n                if (!isMounted.current) return;\n\n                // Set loading state\n                setImageLoadingStates(prev => ({\n                  ...prev,\n                  [image.id]: true\n                }));\n\n                // Add a small delay before attempting recovery to prevent rapid retries\n                setTimeout(() => {\n                  // Check again if component is still mounted\n                  if (isMounted.current) {\n                    // Call the refresh image function to attempt recovery\n                    handleRefreshImage(image);\n                  }\n                }, 500);\n              }\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 494,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n              style: {\n                position: 'absolute',\n                top: '5px',\n                right: '5px',\n                background: 'rgba(255, 255, 255, 0.7)',\n                border: 'none',\n                borderRadius: '50%',\n                width: '30px',\n                height: '30px',\n                cursor: 'pointer',\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center'\n              },\n              onClick: () => handleRefreshImage(image),\n              title: \"Refresh image\",\n              disabled: imageLoadingStates[image.id],\n              children: imageLoadingStates[image.id] ? '⌛' : '↻'\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 526,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 477,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"image-info\",\n            children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n              children: [\"Image #\", image.id]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 550,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n              children: [\"Hash: \", image.sha256_hash.substring(0, 10), \"...\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 551,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n              children: [\"Uploaded: \", new Date(image.uploaded_at).toLocaleString()]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 552,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n              children: [\"Deepfake: \", image.deepfake_label, \" (\", Math.round(image.deepfake_confidence * 100), \"%)\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 553,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 549,\n            columnNumber: 15\n          }, this)]\n        }, image.id, true, {\n          fileName: _jsxFileName,\n          lineNumber: 476,\n          columnNumber: 13\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 474,\n        columnNumber: 9\n      }, this), !loading && myImages.length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"pagination-controls\",\n        style: {\n          display: 'flex',\n          justifyContent: 'center',\n          alignItems: 'center',\n          margin: '20px 0 40px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"btn\",\n          onClick: previousPage,\n          disabled: !pagination.hasPrevious,\n          style: {\n            margin: '0 5px',\n            opacity: pagination.hasPrevious ? 1 : 0.5,\n            cursor: pagination.hasPrevious ? 'pointer' : 'not-allowed'\n          },\n          children: \"\\xAB Previous\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 567,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            margin: '0 15px'\n          },\n          children: Array.from({\n            length: pagination.totalPages\n          }, (_, i) => i + 1).map(page => /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => goToPage(page),\n            style: {\n              margin: '0 5px',\n              padding: '5px 10px',\n              border: page === pagination.currentPage ? '2px solid #007bff' : '1px solid #ccc',\n              borderRadius: '4px',\n              background: page === pagination.currentPage ? '#e6f2ff' : 'white',\n              cursor: 'pointer'\n            },\n            children: page\n          }, page, false, {\n            fileName: _jsxFileName,\n            lineNumber: 583,\n            columnNumber: 17\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 580,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"btn\",\n          onClick: nextPage,\n          disabled: !pagination.hasNext,\n          style: {\n            margin: '0 5px',\n            opacity: pagination.hasNext ? 1 : 0.5,\n            cursor: pagination.hasNext ? 'pointer' : 'not-allowed'\n          },\n          children: \"Next \\xBB\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 600,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 561,\n        columnNumber: 11\n      }, this), !loading && myImages.length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          textAlign: 'center',\n          marginBottom: '30px',\n          color: '#666'\n        },\n        children: [\"Showing page \", pagination.currentPage, \" of \", pagination.totalPages, \" (\", pagination.totalImages, \" total images)\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 617,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 441,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 438,\n    columnNumber: 5\n  }, this);\n};\n_s(Dashboard, \"GOXQCzhehB16O7KS/4JoS+70i+w=\", false, function () {\n  return [useAuth, useImages];\n});\n_c = Dashboard;\nexport default Dashboard;\nvar _c;\n$RefreshReg$(_c, \"Dashboard\");","map":{"version":3,"names":["React","useEffect","useState","useCallback","useMemo","Link","useAuth","useImages","Navbar","normalizeIpfsHash","jsxDEV","_jsxDEV","Fragment","_Fragment","LOCAL_GATEWAY","getIpfsUrl","hash","normalizedHash","Dashboard","_s","user","myImages","loading","error","pagination","getMyImages","getImageDownloadLink","downloadImageFile","nextPage","previousPage","goToPage","imageLoadingStates","setImageLoadingStates","requestQueue","useRef","queue","running","maxConcurrent","maxRetries","abortControllers","Map","add","fn","priority","retryCount","id","Date","now","toString","isMounted","current","queueItem","controller","AbortController","set","unshift","push","processQueue","length","shift","has","get","signal","aborted","delete","name","console","log","backoffDelay","Math","min","pow","setTimeout","abort","clear","forEach","e","currentQueue","preloadImage","image","abortSignal","prev","timeoutPromise","Promise","_","reject","clearTimeout","Error","race","err","initialLoadRef","currentPage","pageSize","timeoutId","response","images","results","preloadedImages","Set","requestIds","requestId","addEventListener","handleDownload","imageId","directResult","success","objectUrl","link","document","createElement","href","setAttribute","body","appendChild","click","removeChild","URL","revokeObjectURL","url","window","open","find","img","downloadUrl","data","ipfsUrls","local","ipfsUrl","ipfsHash","ipfs_hash","alert","handleRefreshImage","imgElement","getElementById","currentSrc","src","includes","children","fileName","_jsxFileName","lineNumber","columnNumber","className","username","role","style","marginTop","to","marginBottom","map","position","width","height","display","alignItems","justifyContent","backgroundColor","borderTopLeftRadius","borderTopRightRadius","alt","objectFit","onError","top","right","background","border","borderRadius","cursor","onClick","title","disabled","sha256_hash","substring","uploaded_at","toLocaleString","deepfake_label","round","deepfake_confidence","margin","hasPrevious","opacity","Array","from","totalPages","i","page","padding","hasNext","textAlign","color","totalImages","_c","$RefreshReg$"],"sources":["C:/Users/Erwachens/Desktop/MyProject/frontend/src/pages/Dashboard.jsx"],"sourcesContent":["import React, { useEffect, useState, useCallback, useMemo } from 'react';\r\nimport { Link } from 'react-router-dom';\r\nimport { useAuth } from '../context/AuthContext';\r\nimport { useImages } from '../context/ImageContext';\r\nimport Navbar from '../components/common/Navbar';\r\nimport { normalizeIpfsHash } from '../util/ipfs';\r\n\r\n// Local IPFS gateway URL\r\nconst LOCAL_GATEWAY = 'http://127.0.0.1:8080/ipfs/';\r\n\r\n// Function to get IPFS URL from hash\r\nconst getIpfsUrl = (hash) => {\r\n  const normalizedHash = normalizeIpfsHash(hash);\r\n  if (!normalizedHash) return '';\r\n  return `${LOCAL_GATEWAY}${normalizedHash}`;\r\n};\r\n\r\nconst Dashboard = () => {\r\n  const { user } = useAuth();\r\n  const { \r\n    myImages, \r\n    loading, \r\n    error, \r\n    pagination,\r\n    getMyImages, \r\n    getImageDownloadLink,\r\n    downloadImageFile,\r\n    nextPage,\r\n    previousPage,\r\n    goToPage\r\n  } = useImages();\r\n\r\n  // Add state to track loading status of individual images\r\n  const [imageLoadingStates, setImageLoadingStates] = useState({});\r\n\r\n  // Enhanced queue for limiting concurrent API requests with retry and backoff\r\n  const requestQueue = React.useRef({\r\n    queue: [],\r\n    running: 0,\r\n    maxConcurrent: 2, // Limit to 2 concurrent requests\r\n    maxRetries: 3,    // Maximum number of retries per request\r\n    abortControllers: new Map(), // Track abort controllers for each request\r\n    \r\n    add(fn, priority = false, retryCount = 0, id = Date.now().toString()) {\r\n      // Skip adding if component is unmounted\r\n      if (!isMounted.current) return;\r\n      \r\n      const queueItem = { fn, retryCount, id };\r\n      \r\n      // Create an AbortController for this request\r\n      const controller = new AbortController();\r\n      this.abortControllers.set(id, controller);\r\n      \r\n      // Add high priority items to the front of the queue\r\n      if (priority) {\r\n        this.queue.unshift(queueItem);\r\n      } else {\r\n        this.queue.push(queueItem);\r\n      }\r\n      \r\n      this.processQueue();\r\n      \r\n      // Return the request ID so it can be aborted later if needed\r\n      return id;\r\n    },\r\n    \r\n    async processQueue() {\r\n      if (this.running >= this.maxConcurrent || this.queue.length === 0 || !isMounted.current) {\r\n        return;\r\n      }\r\n      \r\n      this.running++;\r\n      const { fn, retryCount, id } = this.queue.shift();\r\n      \r\n      // Skip if component is unmounted or this specific request was aborted\r\n      if (!isMounted.current || (this.abortControllers.has(id) && this.abortControllers.get(id).signal.aborted)) {\r\n        this.running--;\r\n        this.abortControllers.delete(id);\r\n        this.processQueue();\r\n        return;\r\n      }\r\n      \r\n      try {\r\n        // Get the abort controller for this request\r\n        const controller = this.abortControllers.get(id);\r\n        \r\n        // Pass the abort signal to the function if it accepts it\r\n        await fn(controller?.signal);\r\n      } catch (error) {\r\n        // Check if the error is due to abortion\r\n        if (error.name === 'AbortError') {\r\n          console.log(`Request ${id} was aborted`);\r\n        } else {\r\n          console.error(\"Error in queue processing:\", error);\r\n          \r\n          // Only retry if the component is still mounted and we haven't exceeded max retries\r\n          if (isMounted.current && retryCount < this.maxRetries) {\r\n            console.log(`Retrying request (attempt ${retryCount + 1} of ${this.maxRetries})...`);\r\n            \r\n            // Calculate backoff delay: 2^retryCount * 1000ms (1s, 2s, 4s, etc.)\r\n            const backoffDelay = Math.min(Math.pow(2, retryCount) * 1000, 10000);\r\n            \r\n            setTimeout(() => {\r\n              if (isMounted.current) {\r\n                // Re-add the failed request to the queue with increased retry count\r\n                this.add(fn, false, retryCount + 1, id);\r\n              }\r\n            }, backoffDelay);\r\n          }\r\n        }\r\n      } finally {\r\n        this.running--;\r\n        this.abortControllers.delete(id);\r\n        \r\n        // Only continue processing if component is still mounted\r\n        if (isMounted.current) {\r\n          // Add a small delay between requests to prevent overwhelming the server\r\n          setTimeout(() => {\r\n            this.processQueue();\r\n          }, 100);\r\n        }\r\n      }\r\n    },\r\n    \r\n    // Abort a specific request\r\n    abort(id) {\r\n      if (this.abortControllers.has(id)) {\r\n        this.abortControllers.get(id).abort();\r\n        this.abortControllers.delete(id);\r\n      }\r\n    },\r\n    \r\n    // Clear the queue and abort all pending requests\r\n    clear() {\r\n      // Abort all pending requests\r\n      this.abortControllers.forEach(controller => {\r\n        try {\r\n          controller.abort();\r\n        } catch (e) {\r\n          console.error(\"Error aborting request:\", e);\r\n        }\r\n      });\r\n      \r\n      this.queue = [];\r\n      this.abortControllers.clear();\r\n    }\r\n  });\r\n\r\n  // Reference to track if the component is mounted\r\n  const isMounted = React.useRef(true);\r\n  \r\n  // Clear the request queue when component unmounts\r\n  useEffect(() => {\r\n    // Store a reference to the current queue for cleanup\r\n    const currentQueue = requestQueue.current;\r\n    \r\n    return () => {\r\n      isMounted.current = false;\r\n      currentQueue.clear();\r\n    };\r\n  }, []);\r\n  \r\n  // Create a memoized version of the preload function to avoid recreating it on every render\r\n  const preloadImage = useCallback(async (image, abortSignal) => {\r\n    if (!isMounted.current) return;\r\n    \r\n    setImageLoadingStates(prev => ({ ...prev, [image.id]: true }));\r\n    try {\r\n      // Create a timeout promise that rejects after a certain time\r\n      const timeoutPromise = new Promise((_, reject) => {\r\n        const id = setTimeout(() => {\r\n          clearTimeout(id);\r\n          reject(new Error(`Preload timeout for image ${image.id}`));\r\n        }, 15000); // 15 second timeout\r\n      });\r\n      \r\n      // Race the actual request against the timeout\r\n      await Promise.race([\r\n        getImageDownloadLink(image.id),\r\n        timeoutPromise\r\n      ]);\r\n      \r\n      // Check if component is still mounted or if the request was aborted\r\n      if (!isMounted.current || (abortSignal && abortSignal.aborted)) return;\r\n      \r\n      console.log(`Preloaded image ${image.id}`);\r\n    } catch (err) {\r\n      // Check if component is still mounted or if the request was aborted\r\n      if (!isMounted.current || (abortSignal && abortSignal.aborted)) return;\r\n      \r\n      // Check if it's an abort error\r\n      if (err.name === 'AbortError') {\r\n        console.log(`Preload aborted for image ${image.id}`);\r\n      } else {\r\n        console.error(`Failed to preload image ${image.id}:`, err);\r\n      }\r\n    } finally {\r\n      // Only update state if component is still mounted and request wasn't aborted\r\n      if (isMounted.current && !(abortSignal && abortSignal.aborted)) {\r\n        setImageLoadingStates(prev => ({ ...prev, [image.id]: false }));\r\n      }\r\n    }\r\n  }, [getImageDownloadLink]);\r\n\r\n  // Track if initial load has happened\r\n  const initialLoadRef = React.useRef(false);\r\n  \r\n  // Fetch user's images when component mounts or pagination changes\r\n  useEffect(() => {\r\n    // Skip if this is just a re-render and not a pagination change\r\n    if (initialLoadRef.current && \r\n        pagination.currentPage === 1 && \r\n        pagination.pageSize === 9 && \r\n        myImages.length > 0) {\r\n      return;\r\n    }\r\n    \r\n    // Set initial load flag\r\n    initialLoadRef.current = true;\r\n    \r\n    // Create an AbortController for this effect\r\n    const controller = new AbortController();\r\n    const { signal } = controller;\r\n    \r\n    // Use a debounce mechanism to prevent multiple rapid calls\r\n    const timeoutId = setTimeout(async () => {\r\n      if (!isMounted.current || signal.aborted) return;\r\n      \r\n      try {\r\n        // Load the current page of images with abort signal\r\n        const response = await getMyImages(pagination.currentPage, pagination.pageSize);\r\n        if (!isMounted.current || signal.aborted) return;\r\n        \r\n        const images = response.results || [];\r\n        console.log(`Loaded ${images.length} images for page ${pagination.currentPage}`);\r\n        \r\n        // Create a Set to track which images we've already started preloading\r\n        const preloadedImages = new Set();\r\n        \r\n        // Store request IDs for cleanup\r\n        const requestIds = [];\r\n        \r\n        // Preload images sequentially using the request queue to limit concurrent requests\r\n        // Only preload visible images to reduce unnecessary requests\r\n        images.forEach(image => {\r\n          if (!isMounted.current || signal.aborted) return;\r\n          \r\n          // Skip if we've already started preloading this image\r\n          if (preloadedImages.has(image.id)) {\r\n            return;\r\n          }\r\n          \r\n          // Mark this image as being preloaded\r\n          preloadedImages.add(image.id);\r\n          \r\n          // Add to queue and store request ID\r\n          const requestId = requestQueue.current.add(async (abortSignal) => {\r\n            await preloadImage(image, abortSignal);\r\n          });\r\n          \r\n          if (requestId) {\r\n            requestIds.push(requestId);\r\n          }\r\n        });\r\n        \r\n        // Add cleanup for these specific requests\r\n        signal.addEventListener('abort', () => {\r\n          requestIds.forEach(id => requestQueue.current.abort(id));\r\n        });\r\n        \r\n      } catch (err) {\r\n        if (!isMounted.current || signal.aborted) return;\r\n        \r\n        if (err.name === 'AbortError') {\r\n          console.log('Image loading aborted');\r\n        } else {\r\n          console.error('Failed to load images:', err);\r\n        }\r\n      }\r\n    }, 300); // 300ms debounce delay\r\n    \r\n    // Cleanup function to cancel any pending operations if the dependencies change\r\n    return () => {\r\n      clearTimeout(timeoutId);\r\n      controller.abort();\r\n    };\r\n  }, [\r\n    pagination.currentPage,\r\n    pagination.pageSize,\r\n    getMyImages,\r\n    preloadImage,\r\n    myImages.length\r\n  ]);\r\n\r\n  // eslint-disable-next-line no-unused-vars\r\n  const handleDownload = async (imageId) => {\r\n    try {\r\n      // First try the direct download method\r\n      console.log(`Attempting direct download for image ${imageId}`);\r\n      setImageLoadingStates(prev => ({ ...prev, [imageId]: true }));\r\n      \r\n      const directResult = await downloadImageFile(imageId);\r\n      \r\n      if (directResult.success) {\r\n        console.log(`Direct download successful for image ${imageId}`);\r\n        \r\n        // If we got an objectUrl (blob), create a download link\r\n        if (directResult.objectUrl) {\r\n          // Create a temporary anchor element to trigger download\r\n          const link = document.createElement('a');\r\n          link.href = directResult.objectUrl;\r\n          link.setAttribute('download', `image-${imageId}.jpg`);\r\n          document.body.appendChild(link);\r\n          link.click();\r\n          document.body.removeChild(link);\r\n          \r\n          // Clean up the object URL to avoid memory leaks\r\n          setTimeout(() => URL.revokeObjectURL(directResult.objectUrl), 100);\r\n          \r\n          console.log(`Download initiated for image ${imageId} using blob`);\r\n        } \r\n        // If we got a fallback URL, open it in a new tab\r\n        else if (directResult.url) {\r\n          window.open(directResult.url, '_blank');\r\n          console.log(`Download initiated for image ${imageId} using fallback URL`);\r\n        }\r\n      } else {\r\n        // If direct download failed, fall back to the old method\r\n        console.log(`Direct download failed for image ${imageId}, falling back to link method`);\r\n        \r\n        const response = await getImageDownloadLink(imageId);\r\n        console.log(`Download link response for image ${imageId}:`, response);\r\n        \r\n        // Get the image from our state\r\n        const image = myImages.find(img => img.id === imageId);\r\n        if (!image) {\r\n          console.error(`Image ${imageId} not found in state`);\r\n          return;\r\n        }\r\n        \r\n        // Get the best available URL (local or public)\r\n        let downloadUrl;\r\n        if (response.data && response.data.ipfsUrls && response.data.ipfsUrls.local) {\r\n          downloadUrl = response.data.ipfsUrls.local;\r\n          console.log(`Using local URL from response: ${downloadUrl}`);\r\n        } else if (response.data && response.data.ipfsUrl) {\r\n          // Fallback to the original URL if the new structure isn't available\r\n          downloadUrl = response.data.ipfsUrl;\r\n          console.log(`Using original URL from response: ${downloadUrl}`);\r\n        } else {\r\n          // If no URL is available, construct one from the hash using our utility\r\n          const hash = (response.data && response.data.ipfsHash) || image.ipfs_hash;\r\n          const normalizedHash = normalizeIpfsHash(hash);\r\n          downloadUrl = normalizedHash ? `${LOCAL_GATEWAY}${normalizedHash}` : '';\r\n          console.log(`Constructed URL from hash: ${downloadUrl}`);\r\n        }\r\n        \r\n        // Create a temporary anchor element to trigger download\r\n        const link = document.createElement('a');\r\n        link.href = downloadUrl;\r\n        link.setAttribute('download', `image-${imageId}.jpg`);\r\n        link.setAttribute('target', '_blank');\r\n        document.body.appendChild(link);\r\n        link.click();\r\n        document.body.removeChild(link);\r\n        \r\n        console.log(`Download initiated for image ${imageId} using fallback method`);\r\n      }\r\n    } catch (err) {\r\n      console.error('Failed to download image:', err);\r\n      alert('Failed to download image. Please try again later.');\r\n    } finally {\r\n      setImageLoadingStates(prev => ({ ...prev, [imageId]: false }));\r\n    }\r\n  };\r\n\r\n  // Memoize the refresh image handler to prevent recreation on each render\r\n  const handleRefreshImage = useCallback(async (image) => {\r\n    // Skip if component is unmounted\r\n    if (!isMounted.current) return;\r\n    \r\n    // Set loading state\r\n    setImageLoadingStates(prev => ({ ...prev, [image.id]: true }));\r\n    \r\n    // Create an AbortController for this operation\r\n    const controller = new AbortController();\r\n    const { signal } = controller;\r\n    \r\n    // Set a timeout to abort the request if it takes too long\r\n    const timeoutId = setTimeout(() => {\r\n      controller.abort();\r\n      console.log(`Refresh timeout for image ${image.id}`);\r\n      \r\n      // Reset loading state if component is still mounted\r\n      if (isMounted.current) {\r\n        setImageLoadingStates(prev => ({ ...prev, [image.id]: false }));\r\n      }\r\n    }, 10000); // 10 second timeout\r\n    \r\n    try {\r\n      // Attempt to refresh the image by getting a new download link\r\n      await getImageDownloadLink(image.id);\r\n      \r\n      // Skip further processing if component unmounted or request was aborted\r\n      if (!isMounted.current || signal.aborted) return;\r\n      \r\n      console.log(`Successfully refreshed image ${image.id}`);\r\n      \r\n      // Force reload the image by updating its src\r\n      const imgElement = document.getElementById(`img-${image.id}`);\r\n      if (imgElement) {\r\n        const currentSrc = imgElement.src;\r\n        imgElement.src = '';\r\n        // Add a cache-busting parameter\r\n        imgElement.src = `${currentSrc}${currentSrc.includes('?') ? '&' : '?'}t=${Date.now()}`;\r\n      }\r\n    } catch (err) {\r\n      // Skip error handling if component unmounted or request was aborted\r\n      if (!isMounted.current || signal.aborted) return;\r\n      \r\n      if (err.name === 'AbortError') {\r\n        console.log(`Refresh aborted for image ${image.id}`);\r\n      } else {\r\n        console.error(`Error refreshing image ${image.id}:`, err);\r\n      }\r\n    } finally {\r\n      // Clear the timeout\r\n      clearTimeout(timeoutId);\r\n      \r\n      // Only update state if component is still mounted and request wasn't aborted\r\n      if (isMounted.current && !signal.aborted) {\r\n        setImageLoadingStates(prev => ({ ...prev, [image.id]: false }));\r\n      }\r\n    }\r\n  }, [getImageDownloadLink]);\r\n\r\n  return (\r\n    <div>\r\n      <Navbar />\r\n      \r\n      <div className=\"container\">\r\n        <div className=\"card\">\r\n          <h2>Welcome, {user?.username}!</h2>\r\n          <p>Role: {user?.role}</p>\r\n          \r\n          <div style={{ marginTop: '20px' }}>\r\n            <Link to=\"/upload\" className=\"btn\">Upload New Image</Link>\r\n            \r\n            \r\n\r\n            {user?.role === 'admin' && (\r\n              <>\r\n              </>\r\n            )}\r\n          </div>\r\n        </div>\r\n        \r\n        <h3 style={{ marginTop: '30px' }}>My Images</h3>\r\n        \r\n        {loading && (\r\n          <div className=\"spinner\"></div>\r\n        )}\r\n        \r\n        {error && (\r\n          <div className=\"alert alert-danger\">{error}</div>\r\n        )}\r\n        \r\n        {!loading && myImages.length === 0 && (\r\n          <div className=\"card\">\r\n            <p>You haven't uploaded any images yet.</p>\r\n          </div>\r\n        )}\r\n        \r\n        <div className=\"image-grid\" style={{ marginBottom: '20px' }}>\r\n          {myImages.map((image) => (\r\n            <div key={image.id} className=\"image-card\">\r\n              <div style={{ position: 'relative' }}>\r\n                {imageLoadingStates[image.id] ? (\r\n                  <div \r\n                    style={{ \r\n                      width: '100%', \r\n                      height: '200px',\r\n                      display: 'flex',\r\n                      alignItems: 'center',\r\n                      justifyContent: 'center',\r\n                      backgroundColor: '#f0f0f0',\r\n                      borderTopLeftRadius: '8px',\r\n                      borderTopRightRadius: '8px'\r\n                    }}\r\n                  >\r\n                    <div className=\"spinner\" style={{ width: '40px', height: '40px' }}></div>\r\n                  </div>\r\n                ) : (\r\n                  <img \r\n                    id={`img-${image.id}`}\r\n                    src={getIpfsUrl(image.ipfs_hash)}\r\n                    alt={`ID: ${image.id}`}\r\n                    style={{ \r\n                      width: '100%', \r\n                      height: '200px', \r\n                      objectFit: 'cover',\r\n                      borderTopLeftRadius: '8px',\r\n                      borderTopRightRadius: '8px'\r\n                    }}\r\n                    onError={(e) => {\r\n                      console.log(`Image ${image.id} failed to load, attempting to recover...`);\r\n                      \r\n                      // Skip if component is unmounted\r\n                      if (!isMounted.current) return;\r\n                      \r\n                      // Set loading state\r\n                      setImageLoadingStates(prev => ({ ...prev, [image.id]: true }));\r\n                      \r\n                      // Add a small delay before attempting recovery to prevent rapid retries\r\n                      setTimeout(() => {\r\n                        // Check again if component is still mounted\r\n                        if (isMounted.current) {\r\n                          // Call the refresh image function to attempt recovery\r\n                          handleRefreshImage(image);\r\n                        }\r\n                      }, 500);\r\n                    }}\r\n                  />\r\n                )}\r\n                {/* Add a refresh button to retry loading the image */}\r\n                <button \r\n                  style={{\r\n                    position: 'absolute',\r\n                    top: '5px',\r\n                    right: '5px',\r\n                    background: 'rgba(255, 255, 255, 0.7)',\r\n                    border: 'none',\r\n                    borderRadius: '50%',\r\n                    width: '30px',\r\n                    height: '30px',\r\n                    cursor: 'pointer',\r\n                    display: 'flex',\r\n                    alignItems: 'center',\r\n                    justifyContent: 'center'\r\n                  }}\r\n                  onClick={() => handleRefreshImage(image)}\r\n                  title=\"Refresh image\"\r\n                  disabled={imageLoadingStates[image.id]}\r\n                >\r\n                  {imageLoadingStates[image.id] ? '⌛' : '↻'}\r\n                </button>\r\n              </div>\r\n              \r\n              <div className=\"image-info\">\r\n                <h3>Image #{image.id}</h3>\r\n                <p>Hash: {image.sha256_hash.substring(0, 10)}...</p>\r\n                <p>Uploaded: {new Date(image.uploaded_at).toLocaleString()}</p>\r\n                <p>Deepfake: {image.deepfake_label} ({Math.round(image.deepfake_confidence * 100)}%)</p>\r\n              </div>\r\n            </div>\r\n          ))}\r\n        </div>\r\n        \r\n        {/* Pagination Controls */}\r\n        {!loading && myImages.length > 0 && (\r\n          <div className=\"pagination-controls\" style={{ \r\n            display: 'flex', \r\n            justifyContent: 'center', \r\n            alignItems: 'center', \r\n            margin: '20px 0 40px' \r\n          }}>\r\n            <button \r\n              className=\"btn\" \r\n              onClick={previousPage} \r\n              disabled={!pagination.hasPrevious}\r\n              style={{ \r\n                margin: '0 5px',\r\n                opacity: pagination.hasPrevious ? 1 : 0.5,\r\n                cursor: pagination.hasPrevious ? 'pointer' : 'not-allowed'\r\n              }}\r\n            >\r\n              &laquo; Previous\r\n            </button>\r\n            \r\n            <div style={{ margin: '0 15px' }}>\r\n              {/* Page numbers */}\r\n              {Array.from({ length: pagination.totalPages }, (_, i) => i + 1).map(page => (\r\n                <button\r\n                  key={page}\r\n                  onClick={() => goToPage(page)}\r\n                  style={{\r\n                    margin: '0 5px',\r\n                    padding: '5px 10px',\r\n                    border: page === pagination.currentPage ? '2px solid #007bff' : '1px solid #ccc',\r\n                    borderRadius: '4px',\r\n                    background: page === pagination.currentPage ? '#e6f2ff' : 'white',\r\n                    cursor: 'pointer'\r\n                  }}\r\n                >\r\n                  {page}\r\n                </button>\r\n              ))}\r\n            </div>\r\n            \r\n            <button \r\n              className=\"btn\" \r\n              onClick={nextPage} \r\n              disabled={!pagination.hasNext}\r\n              style={{ \r\n                margin: '0 5px',\r\n                opacity: pagination.hasNext ? 1 : 0.5,\r\n                cursor: pagination.hasNext ? 'pointer' : 'not-allowed'\r\n              }}\r\n            >\r\n              Next &raquo;\r\n            </button>\r\n          </div>\r\n        )}\r\n        \r\n        {/* Pagination Info */}\r\n        {!loading && myImages.length > 0 && (\r\n          <div style={{ textAlign: 'center', marginBottom: '30px', color: '#666' }}>\r\n            Showing page {pagination.currentPage} of {pagination.totalPages} ({pagination.totalImages} total images)\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Dashboard;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}