{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Erwachens\\\\Desktop\\\\MyProject\\\\frontend\\\\src\\\\components\\\\images\\\\ImageWithAuth.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport api from '../../api';\nimport { normalizeIpfsHash } from '../../util/ipfs';\n\n// Local IPFS gateway URL\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst LOCAL_GATEWAY = 'http://127.0.0.1:8080/ipfs/';\n\n// Function to get IPFS URL from hash with multiple fallback options\nconst getIpfsUrl = (hash, imageId) => {\n  // First try to normalize the hash\n  const normalizedHash = normalizeIpfsHash(hash);\n  if (!normalizedHash) return '';\n\n  // Primary URL: Local gateway\n  const localUrl = `${LOCAL_GATEWAY}${normalizedHash}`;\n\n  // Fallback URL: Direct backend download endpoint\n  const backendUrl = `/api/images/download-file/${imageId}/`;\n\n  // Return both URLs for fallback mechanism\n  return {\n    primary: localUrl,\n    fallback: backendUrl\n  };\n};\n\n/**\r\n * Component for loading images with authentication\r\n * Uses axios interceptors to handle token refresh automatically\r\n */\nconst ImageWithAuth = ({\n  id,\n  imageId,\n  ipfsHash,\n  alt,\n  style,\n  onRefresh,\n  setLoading,\n  isMounted\n}) => {\n  _s();\n  const [imageSrc, setImageSrc] = useState('');\n  const [error, setError] = useState(false);\n  const imageRef = useRef(null);\n  const loadAttempts = useRef(0);\n\n  // Load the image using authenticated API request\n  const loadImage = async () => {\n    if (!isMounted.current) return;\n    try {\n      setLoading(true);\n      setError(false);\n\n      // Use axios with interceptors to handle authentication\n      const response = await api.get(`/api/images/download-file/${imageId}/`, {\n        responseType: 'blob',\n        // Add cache-busting parameter\n        params: {\n          t: Date.now()\n        }\n      });\n      if (!isMounted.current) return;\n\n      // Create an object URL from the blob\n      const objectUrl = URL.createObjectURL(response.data);\n      setImageSrc(objectUrl);\n\n      // Clean up the object URL when the component unmounts or when the src changes\n      return () => {\n        URL.revokeObjectURL(objectUrl);\n      };\n    } catch (err) {\n      if (!isMounted.current) return;\n      console.error(`Error loading image ${imageId}:`, err);\n      setError(true);\n\n      // Try fallback URL if available\n      if (ipfsHash) {\n        const urls = getIpfsUrl(ipfsHash, imageId);\n        setImageSrc(urls.primary);\n      }\n    } finally {\n      if (isMounted.current) {\n        setLoading(false);\n      }\n    }\n  };\n\n  // Load the image on mount and when imageId changes\n  useEffect(() => {\n    loadAttempts.current = 0;\n\n    // Track if component is mounted\n    let isComponentMounted = true;\n\n    // Create a variable to store the cleanup function\n    let cleanupFunction = null;\n\n    // Call loadImage and handle the Promise properly\n    loadImage().then(cleanup => {\n      // Only store the cleanup if component is still mounted\n      if (isComponentMounted && cleanup) {\n        cleanupFunction = cleanup;\n      }\n    }).catch(err => {\n      console.error('Error in loadImage:', err);\n    });\n\n    // Clean up function\n    return () => {\n      // Mark component as unmounted\n      isComponentMounted = false;\n\n      // Call the cleanup function if it exists\n      if (typeof cleanupFunction === 'function') {\n        cleanupFunction();\n      }\n    };\n  }, [imageId]);\n\n  // Handle image load error\n  const handleError = () => {\n    if (!isMounted.current) return;\n\n    // Increment load attempts\n    loadAttempts.current += 1;\n\n    // If we've tried too many times, give up\n    if (loadAttempts.current > 3) {\n      console.log(`Too many load attempts for image ${imageId}, giving up`);\n      setError(true);\n      setLoading(false);\n      return;\n    }\n    console.log(`Image ${imageId} failed to load, attempt ${loadAttempts.current}`);\n\n    // Try fallback URL if we're not already using it\n    if (ipfsHash && imageSrc.includes(LOCAL_GATEWAY)) {\n      const urls = getIpfsUrl(ipfsHash, imageId);\n      console.log(`Switching to fallback URL for image ${imageId}`);\n      setImageSrc(urls.fallback);\n    } else {\n      // If we're already using the fallback URL or don't have an IPFS hash,\n      // try refreshing the image\n      console.log(`All URLs failed for image ${imageId}, trying refresh`);\n      if (onRefresh) {\n        onRefresh();\n      }\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"img\", {\n    ref: imageRef,\n    id: id,\n    src: imageSrc,\n    alt: alt,\n    style: style,\n    onError: handleError\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 154,\n    columnNumber: 5\n  }, this);\n};\n_s(ImageWithAuth, \"0LGzK6mxpU6D391UYqpEceMCZ8Y=\");\n_c = ImageWithAuth;\nexport default ImageWithAuth;\nvar _c;\n$RefreshReg$(_c, \"ImageWithAuth\");","map":{"version":3,"names":["React","useState","useEffect","useRef","api","normalizeIpfsHash","jsxDEV","_jsxDEV","LOCAL_GATEWAY","getIpfsUrl","hash","imageId","normalizedHash","localUrl","backendUrl","primary","fallback","ImageWithAuth","id","ipfsHash","alt","style","onRefresh","setLoading","isMounted","_s","imageSrc","setImageSrc","error","setError","imageRef","loadAttempts","loadImage","current","response","get","responseType","params","t","Date","now","objectUrl","URL","createObjectURL","data","revokeObjectURL","err","console","urls","isComponentMounted","cleanupFunction","then","cleanup","catch","handleError","log","includes","ref","src","onError","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Erwachens/Desktop/MyProject/frontend/src/components/images/ImageWithAuth.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\r\nimport api from '../../api';\r\nimport { normalizeIpfsHash } from '../../util/ipfs';\r\n\r\n// Local IPFS gateway URL\r\nconst LOCAL_GATEWAY = 'http://127.0.0.1:8080/ipfs/';\r\n\r\n// Function to get IPFS URL from hash with multiple fallback options\r\nconst getIpfsUrl = (hash, imageId) => {\r\n  // First try to normalize the hash\r\n  const normalizedHash = normalizeIpfsHash(hash);\r\n  if (!normalizedHash) return '';\r\n  \r\n  // Primary URL: Local gateway\r\n  const localUrl = `${LOCAL_GATEWAY}${normalizedHash}`;\r\n  \r\n  // Fallback URL: Direct backend download endpoint\r\n  const backendUrl = `/api/images/download-file/${imageId}/`;\r\n  \r\n  // Return both URLs for fallback mechanism\r\n  return {\r\n    primary: localUrl,\r\n    fallback: backendUrl\r\n  };\r\n};\r\n\r\n/**\r\n * Component for loading images with authentication\r\n * Uses axios interceptors to handle token refresh automatically\r\n */\r\nconst ImageWithAuth = ({ \r\n  id, \r\n  imageId, \r\n  ipfsHash, \r\n  alt, \r\n  style, \r\n  onRefresh, \r\n  setLoading,\r\n  isMounted \r\n}) => {\r\n  const [imageSrc, setImageSrc] = useState('');\r\n  const [error, setError] = useState(false);\r\n  const imageRef = useRef(null);\r\n  const loadAttempts = useRef(0);\r\n  \r\n  // Load the image using authenticated API request\r\n  const loadImage = async () => {\r\n    if (!isMounted.current) return;\r\n    \r\n    try {\r\n      setLoading(true);\r\n      setError(false);\r\n      \r\n      // Use axios with interceptors to handle authentication\r\n      const response = await api.get(`/api/images/download-file/${imageId}/`, {\r\n        responseType: 'blob',\r\n        // Add cache-busting parameter\r\n        params: { t: Date.now() }\r\n      });\r\n      \r\n      if (!isMounted.current) return;\r\n      \r\n      // Create an object URL from the blob\r\n      const objectUrl = URL.createObjectURL(response.data);\r\n      setImageSrc(objectUrl);\r\n      \r\n      // Clean up the object URL when the component unmounts or when the src changes\r\n      return () => {\r\n        URL.revokeObjectURL(objectUrl);\r\n      };\r\n    } catch (err) {\r\n      if (!isMounted.current) return;\r\n      \r\n      console.error(`Error loading image ${imageId}:`, err);\r\n      setError(true);\r\n      \r\n      // Try fallback URL if available\r\n      if (ipfsHash) {\r\n        const urls = getIpfsUrl(ipfsHash, imageId);\r\n        setImageSrc(urls.primary);\r\n      }\r\n    } finally {\r\n      if (isMounted.current) {\r\n        setLoading(false);\r\n      }\r\n    }\r\n  };\r\n  \r\n  // Load the image on mount and when imageId changes\r\n  useEffect(() => {\r\n    loadAttempts.current = 0;\r\n    \r\n    // Track if component is mounted\r\n    let isComponentMounted = true;\r\n    \r\n    // Create a variable to store the cleanup function\r\n    let cleanupFunction = null;\r\n    \r\n    // Call loadImage and handle the Promise properly\r\n    loadImage().then(cleanup => {\r\n      // Only store the cleanup if component is still mounted\r\n      if (isComponentMounted && cleanup) {\r\n        cleanupFunction = cleanup;\r\n      }\r\n    }).catch(err => {\r\n      console.error('Error in loadImage:', err);\r\n    });\r\n    \r\n    // Clean up function\r\n    return () => {\r\n      // Mark component as unmounted\r\n      isComponentMounted = false;\r\n      \r\n      // Call the cleanup function if it exists\r\n      if (typeof cleanupFunction === 'function') {\r\n        cleanupFunction();\r\n      }\r\n    };\r\n  }, [imageId]);\r\n  \r\n  // Handle image load error\r\n  const handleError = () => {\r\n    if (!isMounted.current) return;\r\n    \r\n    // Increment load attempts\r\n    loadAttempts.current += 1;\r\n    \r\n    // If we've tried too many times, give up\r\n    if (loadAttempts.current > 3) {\r\n      console.log(`Too many load attempts for image ${imageId}, giving up`);\r\n      setError(true);\r\n      setLoading(false);\r\n      return;\r\n    }\r\n    \r\n    console.log(`Image ${imageId} failed to load, attempt ${loadAttempts.current}`);\r\n    \r\n    // Try fallback URL if we're not already using it\r\n    if (ipfsHash && imageSrc.includes(LOCAL_GATEWAY)) {\r\n      const urls = getIpfsUrl(ipfsHash, imageId);\r\n      console.log(`Switching to fallback URL for image ${imageId}`);\r\n      setImageSrc(urls.fallback);\r\n    } else {\r\n      // If we're already using the fallback URL or don't have an IPFS hash,\r\n      // try refreshing the image\r\n      console.log(`All URLs failed for image ${imageId}, trying refresh`);\r\n      if (onRefresh) {\r\n        onRefresh();\r\n      }\r\n    }\r\n  };\r\n  \r\n  return (\r\n    <img\r\n      ref={imageRef}\r\n      id={id}\r\n      src={imageSrc}\r\n      alt={alt}\r\n      style={style}\r\n      onError={handleError}\r\n    />\r\n  );\r\n};\r\n\r\nexport default ImageWithAuth;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}