{"ast":null,"code":"/**\r\n * Enhanced IPFS utilities with local-only gateway usage\r\n */\n\n// Configuration\nconst IPFS_TIMEOUT = 30000; // 30 seconds\nconst MAX_RETRIES = 3;\nconst LOCAL_GATEWAY = 'http://127.0.0.1:8080/ipfs/';\nconst LOCAL_GATEWAYS = ['http://127.0.0.1:8080/ipfs/', 'http://localhost:8080/ipfs/'];\n\n/**\r\n * Normalizes an IPFS hash from various formats\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @returns {string} - The normalized hash string\r\n * @throws {Error} - If hash is invalid\r\n */\nexport const normalizeIpfsHash = hash => {\n  if (!hash) {\n    console.warn('Empty IPFS hash provided');\n    return null;\n  }\n\n  // Extract hash from object if needed\n  if (typeof hash === 'object') {\n    hash = hash.cid || hash.Hash || hash.hash || hash.ipfs_hash;\n  }\n\n  // Handle string that might be JSON\n  if (typeof hash === 'string' && hash.startsWith('{')) {\n    try {\n      const parsed = JSON.parse(hash);\n      hash = parsed.cid || parsed.Hash || parsed.hash || parsed.ipfs_hash;\n    } catch (e) {\n      // If parsing fails, use the string as-is\n      console.warn('Failed to parse IPFS hash JSON:', e);\n    }\n  }\n\n  // Validate hash format\n  if (!hash || typeof hash !== 'string' || hash.length < 10) {\n    console.warn(`Invalid IPFS hash format: ${hash}`);\n    return null;\n  }\n  return hash;\n};\n\n/**\r\n * Check if local gateway is accessible\r\n * @param {string} gateway - Gateway URL to check\r\n * @returns {Promise<boolean>} - True if gateway is accessible\r\n */\nconst isGatewayAccessible = async gateway => {\n  try {\n    const response = await fetch(`${gateway}QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/readme`, {\n      method: 'HEAD',\n      timeout: 5000\n    });\n    return response.ok;\n  } catch {\n    return false;\n  }\n};\n\n/**\r\n * Get the best available local gateway\r\n * @returns {Promise<string>} - Best available local gateway URL\r\n */\nconst getBestLocalGateway = async () => {\n  for (const gateway of LOCAL_GATEWAYS) {\n    if (await isGatewayAccessible(gateway)) {\n      return gateway;\n    }\n  }\n  return LOCAL_GATEWAY; // Default to primary local gateway\n};\n\n/**\r\n * Constructs a local IPFS URL for a given hash\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {boolean} [forceReload=false] - Whether to add cache-busting parameter\r\n * @returns {string} - The complete local IPFS URL\r\n */\nexport const getIpfsUrl = (hash, forceReload = false) => {\n  try {\n    const normalizedHash = normalizeIpfsHash(hash);\n    if (!normalizedHash) {\n      return 'https://via.placeholder.com/300x200?text=Invalid+IPFS+Hash';\n    }\n\n    // Use the first gateway by default without async check\n    const gateway = LOCAL_GATEWAY;\n    const url = `${gateway}${normalizedHash}`;\n    return forceReload ? `${url}?t=${Date.now()}` : url;\n  } catch (error) {\n    console.error('Error constructing IPFS URL:', error);\n    return 'https://via.placeholder.com/300x200?text=Error+Loading+Image';\n  }\n};\n\n/**\r\n * Constructs a local IPFS URL for a given hash with gateway check\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Options for URL construction\r\n * @param {boolean} [options.forceReload=false] - Whether to add cache-busting parameter\r\n * @returns {Promise<string>} - The complete local IPFS URL\r\n */\nexport const getIpfsUrlAsync = async (hash, options = {}) => {\n  try {\n    const normalizedHash = normalizeIpfsHash(hash);\n    if (!normalizedHash) {\n      return 'https://via.placeholder.com/300x200?text=Invalid+IPFS+Hash';\n    }\n    const gateway = await getBestLocalGateway();\n    const url = `${gateway}${normalizedHash}`;\n    return options.forceReload ? `${url}?t=${Date.now()}` : url;\n  } catch (error) {\n    console.error('Error constructing IPFS URL:', error);\n    return 'https://via.placeholder.com/300x200?text=Error+Loading+Image';\n  }\n};\n\n/**\r\n * Check if an image is accessible with progressive loading support\r\n * @param {string} url - Image URL to check\r\n * @param {Object} options - Options for checking\r\n * @param {number} [options.timeout=5000] - Timeout in milliseconds\r\n * @param {Function} [options.onProgress] - Progress callback\r\n * @returns {Promise<boolean>} - True if image is accessible\r\n */\nexport const isImageAccessible = async (url, options = {}) => {\n  const {\n    timeout = 5000,\n    onProgress\n  } = options;\n  return new Promise(resolve => {\n    const img = new Image();\n    let timeoutId;\n    const cleanup = () => {\n      if (timeoutId) clearTimeout(timeoutId);\n      img.onload = img.onerror = null;\n    };\n    if (onProgress) {\n      img.onprogress = event => {\n        if (event.lengthComputable) {\n          onProgress(event.loaded / event.total);\n        }\n      };\n    }\n    img.onload = () => {\n      cleanup();\n      resolve(true);\n    };\n    img.onerror = () => {\n      cleanup();\n      resolve(false);\n    };\n    timeoutId = setTimeout(() => {\n      cleanup();\n      resolve(false);\n    }, timeout);\n    img.src = url;\n  });\n};\n\n/**\r\n * Get the best available local IPFS URL for an image with progressive loading\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Options for URL retrieval\r\n * @param {number} [options.maxRetries=3] - Maximum number of retries\r\n * @param {Function} [options.onProgress] - Progress callback\r\n * @returns {Promise<string>} - Best available local URL\r\n */\nexport const getBestIpfsUrl = async (hash, options = {}) => {\n  const {\n    maxRetries = MAX_RETRIES,\n    onProgress\n  } = options;\n  let lastError;\n  try {\n    const normalizedHash = normalizeIpfsHash(hash);\n    if (!normalizedHash) {\n      return 'https://via.placeholder.com/300x200?text=Invalid+IPFS+Hash';\n    }\n\n    // Try each local gateway with retries\n    for (const gateway of LOCAL_GATEWAYS) {\n      for (let attempt = 0; attempt < maxRetries; attempt++) {\n        try {\n          // Construct URL with the current gateway\n          const url = getIpfsUrl(normalizedHash, attempt > 0);\n          if (url.includes('placeholder.com')) {\n            continue; // Skip if we got a placeholder URL\n          }\n          const isAccessible = await isImageAccessible(url, {\n            timeout: IPFS_TIMEOUT,\n            onProgress\n          });\n          if (isAccessible) {\n            return url;\n          }\n\n          // Wait before retry with exponential backoff\n          if (attempt < maxRetries - 1) {\n            await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\n          }\n        } catch (error) {\n          lastError = error;\n          console.warn(`Attempt ${attempt + 1} failed for gateway ${gateway}:`, error);\n        }\n      }\n    }\n    console.error('Failed to get accessible local IPFS URL:', lastError);\n    return 'https://via.placeholder.com/300x200?text=Image+Not+Accessible';\n  } catch (error) {\n    console.error('Error getting best IPFS URL:', error);\n    return 'https://via.placeholder.com/300x200?text=Error+Loading+Image';\n  }\n};\n\n/**\r\n * Preload an IPFS image using local gateway\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Preload options\r\n * @returns {Promise<boolean>} - True if preload successful\r\n */\nexport const preloadIpfsImage = async (hash, options = {}) => {\n  try {\n    const url = await getBestIpfsUrl(hash, {\n      maxRetries: 5,\n      ...options\n    });\n\n    // If we got a placeholder URL, preload failed\n    if (url.includes('placeholder.com')) {\n      console.warn('Preload failed, got placeholder URL');\n      return false;\n    }\n    return await isImageAccessible(url, {\n      timeout: IPFS_TIMEOUT * 2,\n      ...options\n    });\n  } catch (error) {\n    console.error('Error preloading IPFS image:', error);\n    return false;\n  }\n};\n\n/**\r\n * Monitor local IPFS connection status\r\n * @returns {Promise<boolean>} - True if local IPFS is accessible\r\n */\nexport const checkIpfsConnection = async () => {\n  try {\n    const gateway = await getBestLocalGateway();\n    return Boolean(gateway);\n  } catch {\n    return false;\n  }\n};","map":{"version":3,"names":["IPFS_TIMEOUT","MAX_RETRIES","LOCAL_GATEWAY","LOCAL_GATEWAYS","normalizeIpfsHash","hash","console","warn","cid","Hash","ipfs_hash","startsWith","parsed","JSON","parse","e","length","isGatewayAccessible","gateway","response","fetch","method","timeout","ok","getBestLocalGateway","getIpfsUrl","forceReload","normalizedHash","url","Date","now","error","getIpfsUrlAsync","options","isImageAccessible","onProgress","Promise","resolve","img","Image","timeoutId","cleanup","clearTimeout","onload","onerror","onprogress","event","lengthComputable","loaded","total","setTimeout","src","getBestIpfsUrl","maxRetries","lastError","attempt","includes","isAccessible","Math","pow","preloadIpfsImage","checkIpfsConnection","Boolean"],"sources":["C:/Users/Erwachens/Desktop/MyProject/frontend/src/util/ipfs.js"],"sourcesContent":["/**\r\n * Enhanced IPFS utilities with local-only gateway usage\r\n */\r\n\r\n// Configuration\r\nconst IPFS_TIMEOUT = 30000; // 30 seconds\r\nconst MAX_RETRIES = 3;\r\nconst LOCAL_GATEWAY = 'http://127.0.0.1:8080/ipfs/';\r\nconst LOCAL_GATEWAYS = [\r\n  'http://127.0.0.1:8080/ipfs/',\r\n  'http://localhost:8080/ipfs/',\r\n];\r\n\r\n/**\r\n * Normalizes an IPFS hash from various formats\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @returns {string} - The normalized hash string\r\n * @throws {Error} - If hash is invalid\r\n */\r\nexport const normalizeIpfsHash = (hash) => {\r\n  if (!hash) {\r\n    console.warn('Empty IPFS hash provided');\r\n    return null;\r\n  }\r\n  \r\n  // Extract hash from object if needed\r\n  if (typeof hash === 'object') {\r\n    hash = hash.cid || hash.Hash || hash.hash || hash.ipfs_hash;\r\n  }\r\n  \r\n  // Handle string that might be JSON\r\n  if (typeof hash === 'string' && hash.startsWith('{')) {\r\n    try {\r\n      const parsed = JSON.parse(hash);\r\n      hash = parsed.cid || parsed.Hash || parsed.hash || parsed.ipfs_hash;\r\n    } catch (e) {\r\n      // If parsing fails, use the string as-is\r\n      console.warn('Failed to parse IPFS hash JSON:', e);\r\n    }\r\n  }\r\n  \r\n  // Validate hash format\r\n  if (!hash || typeof hash !== 'string' || hash.length < 10) {\r\n    console.warn(`Invalid IPFS hash format: ${hash}`);\r\n    return null;\r\n  }\r\n  \r\n  return hash;\r\n};\r\n\r\n/**\r\n * Check if local gateway is accessible\r\n * @param {string} gateway - Gateway URL to check\r\n * @returns {Promise<boolean>} - True if gateway is accessible\r\n */\r\nconst isGatewayAccessible = async (gateway) => {\r\n  try {\r\n    const response = await fetch(`${gateway}QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG/readme`, {\r\n      method: 'HEAD',\r\n      timeout: 5000\r\n    });\r\n    return response.ok;\r\n  } catch {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Get the best available local gateway\r\n * @returns {Promise<string>} - Best available local gateway URL\r\n */\r\nconst getBestLocalGateway = async () => {\r\n  for (const gateway of LOCAL_GATEWAYS) {\r\n    if (await isGatewayAccessible(gateway)) {\r\n      return gateway;\r\n    }\r\n  }\r\n  return LOCAL_GATEWAY; // Default to primary local gateway\r\n};\r\n\r\n/**\r\n * Constructs a local IPFS URL for a given hash\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {boolean} [forceReload=false] - Whether to add cache-busting parameter\r\n * @returns {string} - The complete local IPFS URL\r\n */\r\nexport const getIpfsUrl = (hash, forceReload = false) => {\r\n  try {\r\n    const normalizedHash = normalizeIpfsHash(hash);\r\n    if (!normalizedHash) {\r\n      return 'https://via.placeholder.com/300x200?text=Invalid+IPFS+Hash';\r\n    }\r\n    \r\n    // Use the first gateway by default without async check\r\n    const gateway = LOCAL_GATEWAY;\r\n    const url = `${gateway}${normalizedHash}`;\r\n    \r\n    return forceReload ? `${url}?t=${Date.now()}` : url;\r\n  } catch (error) {\r\n    console.error('Error constructing IPFS URL:', error);\r\n    return 'https://via.placeholder.com/300x200?text=Error+Loading+Image';\r\n  }\r\n};\r\n\r\n/**\r\n * Constructs a local IPFS URL for a given hash with gateway check\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Options for URL construction\r\n * @param {boolean} [options.forceReload=false] - Whether to add cache-busting parameter\r\n * @returns {Promise<string>} - The complete local IPFS URL\r\n */\r\nexport const getIpfsUrlAsync = async (hash, options = {}) => {\r\n  try {\r\n    const normalizedHash = normalizeIpfsHash(hash);\r\n    if (!normalizedHash) {\r\n      return 'https://via.placeholder.com/300x200?text=Invalid+IPFS+Hash';\r\n    }\r\n    \r\n    const gateway = await getBestLocalGateway();\r\n    const url = `${gateway}${normalizedHash}`;\r\n    \r\n    return options.forceReload ? `${url}?t=${Date.now()}` : url;\r\n  } catch (error) {\r\n    console.error('Error constructing IPFS URL:', error);\r\n    return 'https://via.placeholder.com/300x200?text=Error+Loading+Image';\r\n  }\r\n};\r\n\r\n/**\r\n * Check if an image is accessible with progressive loading support\r\n * @param {string} url - Image URL to check\r\n * @param {Object} options - Options for checking\r\n * @param {number} [options.timeout=5000] - Timeout in milliseconds\r\n * @param {Function} [options.onProgress] - Progress callback\r\n * @returns {Promise<boolean>} - True if image is accessible\r\n */\r\nexport const isImageAccessible = async (url, options = {}) => {\r\n  const { timeout = 5000, onProgress } = options;\r\n  \r\n  return new Promise((resolve) => {\r\n    const img = new Image();\r\n    let timeoutId;\r\n    \r\n    const cleanup = () => {\r\n      if (timeoutId) clearTimeout(timeoutId);\r\n      img.onload = img.onerror = null;\r\n    };\r\n    \r\n    if (onProgress) {\r\n      img.onprogress = (event) => {\r\n        if (event.lengthComputable) {\r\n          onProgress(event.loaded / event.total);\r\n        }\r\n      };\r\n    }\r\n    \r\n    img.onload = () => {\r\n      cleanup();\r\n      resolve(true);\r\n    };\r\n    \r\n    img.onerror = () => {\r\n      cleanup();\r\n      resolve(false);\r\n    };\r\n    \r\n    timeoutId = setTimeout(() => {\r\n      cleanup();\r\n      resolve(false);\r\n    }, timeout);\r\n    \r\n    img.src = url;\r\n  });\r\n};\r\n\r\n/**\r\n * Get the best available local IPFS URL for an image with progressive loading\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Options for URL retrieval\r\n * @param {number} [options.maxRetries=3] - Maximum number of retries\r\n * @param {Function} [options.onProgress] - Progress callback\r\n * @returns {Promise<string>} - Best available local URL\r\n */\r\nexport const getBestIpfsUrl = async (hash, options = {}) => {\r\n  const { maxRetries = MAX_RETRIES, onProgress } = options;\r\n  let lastError;\r\n  \r\n  try {\r\n    const normalizedHash = normalizeIpfsHash(hash);\r\n    if (!normalizedHash) {\r\n      return 'https://via.placeholder.com/300x200?text=Invalid+IPFS+Hash';\r\n    }\r\n    \r\n    // Try each local gateway with retries\r\n    for (const gateway of LOCAL_GATEWAYS) {\r\n      for (let attempt = 0; attempt < maxRetries; attempt++) {\r\n        try {\r\n          // Construct URL with the current gateway\r\n          const url = getIpfsUrl(normalizedHash, attempt > 0);\r\n          \r\n          if (url.includes('placeholder.com')) {\r\n            continue; // Skip if we got a placeholder URL\r\n          }\r\n          \r\n          const isAccessible = await isImageAccessible(url, {\r\n            timeout: IPFS_TIMEOUT,\r\n            onProgress\r\n          });\r\n          \r\n          if (isAccessible) {\r\n            return url;\r\n          }\r\n          \r\n          // Wait before retry with exponential backoff\r\n          if (attempt < maxRetries - 1) {\r\n            await new Promise(resolve => \r\n              setTimeout(resolve, Math.pow(2, attempt) * 1000)\r\n            );\r\n          }\r\n        } catch (error) {\r\n          lastError = error;\r\n          console.warn(`Attempt ${attempt + 1} failed for gateway ${gateway}:`, error);\r\n        }\r\n      }\r\n    }\r\n    \r\n    console.error('Failed to get accessible local IPFS URL:', lastError);\r\n    return 'https://via.placeholder.com/300x200?text=Image+Not+Accessible';\r\n  } catch (error) {\r\n    console.error('Error getting best IPFS URL:', error);\r\n    return 'https://via.placeholder.com/300x200?text=Error+Loading+Image';\r\n  }\r\n};\r\n\r\n/**\r\n * Preload an IPFS image using local gateway\r\n * @param {string|object} hash - The IPFS hash/CID\r\n * @param {Object} options - Preload options\r\n * @returns {Promise<boolean>} - True if preload successful\r\n */\r\nexport const preloadIpfsImage = async (hash, options = {}) => {\r\n  try {\r\n    const url = await getBestIpfsUrl(hash, {\r\n      maxRetries: 5,\r\n      ...options\r\n    });\r\n    \r\n    // If we got a placeholder URL, preload failed\r\n    if (url.includes('placeholder.com')) {\r\n      console.warn('Preload failed, got placeholder URL');\r\n      return false;\r\n    }\r\n    \r\n    return await isImageAccessible(url, {\r\n      timeout: IPFS_TIMEOUT * 2,\r\n      ...options\r\n    });\r\n  } catch (error) {\r\n    console.error('Error preloading IPFS image:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Monitor local IPFS connection status\r\n * @returns {Promise<boolean>} - True if local IPFS is accessible\r\n */\r\nexport const checkIpfsConnection = async () => {\r\n  try {\r\n    const gateway = await getBestLocalGateway();\r\n    return Boolean(gateway);\r\n  } catch {\r\n    return false;\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}