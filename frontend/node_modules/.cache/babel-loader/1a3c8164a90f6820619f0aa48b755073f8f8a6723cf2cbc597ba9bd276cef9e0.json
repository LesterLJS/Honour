{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Erwachens\\\\Desktop\\\\MyProject\\\\frontend\\\\src\\\\pages\\\\Dashboard.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState, useCallback, useMemo } from 'react';\nimport { Link } from 'react-router-dom';\nimport { useAuth } from '../context/AuthContext';\nimport { useImages } from '../context/ImageContext';\nimport Navbar from '../components/common/Navbar';\nimport { normalizeIpfsHash } from '../util/ipfs';\n\n// Local IPFS gateway URL\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst LOCAL_GATEWAY = 'http://127.0.0.1:8080/ipfs/';\n\n// Function to get IPFS URL from hash with multiple fallback options\nconst getIpfsUrl = (hash, imageId) => {\n  // First try to normalize the hash\n  const normalizedHash = normalizeIpfsHash(hash);\n  if (!normalizedHash) return '';\n\n  // Primary URL: Local gateway\n  const localUrl = `${LOCAL_GATEWAY}${normalizedHash}`;\n\n  // Fallback URL: Direct backend download endpoint\n  const backendUrl = `/api/images/download-file/${imageId}/`;\n\n  // Return both URLs for fallback mechanism\n  return {\n    primary: localUrl,\n    fallback: backendUrl\n  };\n};\nconst Dashboard = () => {\n  _s();\n  const {\n    user\n  } = useAuth();\n  const {\n    myImages,\n    loading,\n    error,\n    pagination,\n    getMyImages,\n    getImageDownloadLink,\n    downloadImageFile,\n    nextPage,\n    previousPage,\n    goToPage\n  } = useImages();\n\n  // Add state to track loading status of individual images\n  const [imageLoadingStates, setImageLoadingStates] = useState({});\n\n  // Enhanced queue for limiting concurrent API requests with retry and backoff\n  const requestQueue = React.useRef({\n    queue: [],\n    running: 0,\n    maxConcurrent: 2,\n    // Limit to 2 concurrent requests\n    maxRetries: 3,\n    // Maximum number of retries per request\n    abortControllers: new Map(),\n    // Track abort controllers for each request\n\n    add(fn, priority = false, retryCount = 0, id = Date.now().toString()) {\n      // Skip adding if component is unmounted\n      if (!isMounted.current) return;\n      const queueItem = {\n        fn,\n        retryCount,\n        id\n      };\n\n      // Create an AbortController for this request\n      const controller = new AbortController();\n      this.abortControllers.set(id, controller);\n\n      // Add high priority items to the front of the queue\n      if (priority) {\n        this.queue.unshift(queueItem);\n      } else {\n        this.queue.push(queueItem);\n      }\n      this.processQueue();\n\n      // Return the request ID so it can be aborted later if needed\n      return id;\n    },\n    async processQueue() {\n      if (this.running >= this.maxConcurrent || this.queue.length === 0 || !isMounted.current) {\n        return;\n      }\n      this.running++;\n      const {\n        fn,\n        retryCount,\n        id\n      } = this.queue.shift();\n\n      // Skip if component is unmounted or this specific request was aborted\n      if (!isMounted.current || this.abortControllers.has(id) && this.abortControllers.get(id).signal.aborted) {\n        this.running--;\n        this.abortControllers.delete(id);\n        this.processQueue();\n        return;\n      }\n      try {\n        // Get the abort controller for this request\n        const controller = this.abortControllers.get(id);\n\n        // Pass the abort signal to the function if it accepts it\n        await fn(controller === null || controller === void 0 ? void 0 : controller.signal);\n      } catch (error) {\n        // Check if the error is due to abortion\n        if (error.name === 'AbortError') {\n          console.log(`Request ${id} was aborted`);\n        } else {\n          console.error(\"Error in queue processing:\", error);\n\n          // Only retry if the component is still mounted and we haven't exceeded max retries\n          if (isMounted.current && retryCount < this.maxRetries) {\n            console.log(`Retrying request (attempt ${retryCount + 1} of ${this.maxRetries})...`);\n\n            // Calculate backoff delay: 2^retryCount * 1000ms (1s, 2s, 4s, etc.)\n            const backoffDelay = Math.min(Math.pow(2, retryCount) * 1000, 10000);\n            setTimeout(() => {\n              if (isMounted.current) {\n                // Re-add the failed request to the queue with increased retry count\n                this.add(fn, false, retryCount + 1, id);\n              }\n            }, backoffDelay);\n          }\n        }\n      } finally {\n        this.running--;\n        this.abortControllers.delete(id);\n\n        // Only continue processing if component is still mounted\n        if (isMounted.current) {\n          // Add a small delay between requests to prevent overwhelming the server\n          setTimeout(() => {\n            this.processQueue();\n          }, 100);\n        }\n      }\n    },\n    // Abort a specific request\n    abort(id) {\n      if (this.abortControllers.has(id)) {\n        this.abortControllers.get(id).abort();\n        this.abortControllers.delete(id);\n      }\n    },\n    // Clear the queue and abort all pending requests\n    clear() {\n      // Abort all pending requests\n      this.abortControllers.forEach(controller => {\n        try {\n          controller.abort();\n        } catch (e) {\n          console.error(\"Error aborting request:\", e);\n        }\n      });\n      this.queue = [];\n      this.abortControllers.clear();\n    }\n  });\n\n  // Reference to track if the component is mounted\n  const isMounted = React.useRef(true);\n\n  // Clear the request queue when component unmounts\n  useEffect(() => {\n    // Store a reference to the current queue for cleanup\n    const currentQueue = requestQueue.current;\n    return () => {\n      isMounted.current = false;\n      currentQueue.clear();\n    };\n  }, []);\n\n  // Create a memoized version of the preload function to avoid recreating it on every render\n  const preloadImage = useCallback(async (image, abortSignal) => {\n    if (!isMounted.current) return;\n    setImageLoadingStates(prev => ({\n      ...prev,\n      [image.id]: true\n    }));\n    try {\n      // Create a timeout promise that rejects after a certain time\n      const timeoutPromise = new Promise((_, reject) => {\n        const id = setTimeout(() => {\n          clearTimeout(id);\n          reject(new Error(`Preload timeout for image ${image.id}`));\n        }, 15000); // 15 second timeout\n      });\n\n      // Race the actual request against the timeout\n      await Promise.race([getImageDownloadLink(image.id), timeoutPromise]);\n\n      // Check if component is still mounted or if the request was aborted\n      if (!isMounted.current || abortSignal && abortSignal.aborted) return;\n      console.log(`Preloaded image ${image.id}`);\n    } catch (err) {\n      // Check if component is still mounted or if the request was aborted\n      if (!isMounted.current || abortSignal && abortSignal.aborted) return;\n\n      // Check if it's an abort error\n      if (err.name === 'AbortError') {\n        console.log(`Preload aborted for image ${image.id}`);\n      } else {\n        console.error(`Failed to preload image ${image.id}:`, err);\n      }\n    } finally {\n      // Only update state if component is still mounted and request wasn't aborted\n      if (isMounted.current && !(abortSignal && abortSignal.aborted)) {\n        setImageLoadingStates(prev => ({\n          ...prev,\n          [image.id]: false\n        }));\n      }\n    }\n  }, [getImageDownloadLink]);\n\n  // Track if initial load has happened\n  const initialLoadRef = React.useRef(false);\n\n  // Fetch user's images when component mounts or pagination changes\n  useEffect(() => {\n    // Skip if this is just a re-render and not a pagination change\n    if (initialLoadRef.current && pagination.currentPage === 1 && pagination.pageSize === 9 && myImages.length > 0) {\n      return;\n    }\n\n    // Set initial load flag\n    initialLoadRef.current = true;\n\n    // Create an AbortController for this effect\n    const controller = new AbortController();\n    const {\n      signal\n    } = controller;\n\n    // Use a debounce mechanism to prevent multiple rapid calls\n    const timeoutId = setTimeout(async () => {\n      if (!isMounted.current || signal.aborted) return;\n      try {\n        // Load the current page of images with abort signal\n        const response = await getMyImages(pagination.currentPage, pagination.pageSize);\n        if (!isMounted.current || signal.aborted) return;\n        const images = response.results || [];\n        console.log(`Loaded ${images.length} images for page ${pagination.currentPage}`);\n\n        // Create a Set to track which images we've already started preloading\n        const preloadedImages = new Set();\n\n        // Store request IDs for cleanup\n        const requestIds = [];\n\n        // Preload images sequentially using the request queue to limit concurrent requests\n        // Only preload visible images to reduce unnecessary requests\n        images.forEach(image => {\n          if (!isMounted.current || signal.aborted) return;\n\n          // Skip if we've already started preloading this image\n          if (preloadedImages.has(image.id)) {\n            return;\n          }\n\n          // Mark this image as being preloaded\n          preloadedImages.add(image.id);\n\n          // Add to queue and store request ID\n          const requestId = requestQueue.current.add(async abortSignal => {\n            await preloadImage(image, abortSignal);\n          });\n          if (requestId) {\n            requestIds.push(requestId);\n          }\n        });\n\n        // Add cleanup for these specific requests\n        signal.addEventListener('abort', () => {\n          requestIds.forEach(id => requestQueue.current.abort(id));\n        });\n      } catch (err) {\n        if (!isMounted.current || signal.aborted) return;\n        if (err.name === 'AbortError') {\n          console.log('Image loading aborted');\n        } else {\n          console.error('Failed to load images:', err);\n        }\n      }\n    }, 300); // 300ms debounce delay\n\n    // Cleanup function to cancel any pending operations if the dependencies change\n    return () => {\n      clearTimeout(timeoutId);\n      controller.abort();\n    };\n  }, [pagination.currentPage, pagination.pageSize, getMyImages, preloadImage, myImages.length]);\n\n  // eslint-disable-next-line no-unused-vars\n  const handleDownload = async imageId => {\n    try {\n      // First try the direct download method\n      console.log(`Attempting direct download for image ${imageId}`);\n      setImageLoadingStates(prev => ({\n        ...prev,\n        [imageId]: true\n      }));\n      const directResult = await downloadImageFile(imageId);\n      if (directResult.success) {\n        console.log(`Direct download successful for image ${imageId}`);\n\n        // If we got an objectUrl (blob), create a download link\n        if (directResult.objectUrl) {\n          // Create a temporary anchor element to trigger download\n          const link = document.createElement('a');\n          link.href = directResult.objectUrl;\n          link.setAttribute('download', `image-${imageId}.jpg`);\n          document.body.appendChild(link);\n          link.click();\n          document.body.removeChild(link);\n\n          // Clean up the object URL to avoid memory leaks\n          setTimeout(() => URL.revokeObjectURL(directResult.objectUrl), 100);\n          console.log(`Download initiated for image ${imageId} using blob`);\n        }\n        // If we got a fallback URL, open it in a new tab\n        else if (directResult.url) {\n          window.open(directResult.url, '_blank');\n          console.log(`Download initiated for image ${imageId} using fallback URL`);\n        }\n      } else {\n        // If direct download failed, fall back to the old method\n        console.log(`Direct download failed for image ${imageId}, falling back to link method`);\n        const response = await getImageDownloadLink(imageId);\n        console.log(`Download link response for image ${imageId}:`, response);\n\n        // Get the image from our state\n        const image = myImages.find(img => img.id === imageId);\n        if (!image) {\n          console.error(`Image ${imageId} not found in state`);\n          return;\n        }\n\n        // Get the best available URL (local or public)\n        let downloadUrl;\n        if (response.data && response.data.ipfsUrls && response.data.ipfsUrls.local) {\n          downloadUrl = response.data.ipfsUrls.local;\n          console.log(`Using local URL from response: ${downloadUrl}`);\n        } else if (response.data && response.data.ipfsUrl) {\n          // Fallback to the original URL if the new structure isn't available\n          downloadUrl = response.data.ipfsUrl;\n          console.log(`Using original URL from response: ${downloadUrl}`);\n        } else {\n          // If no URL is available, construct one from the hash using our utility\n          const hash = response.data && response.data.ipfsHash || image.ipfs_hash;\n          const normalizedHash = normalizeIpfsHash(hash);\n          downloadUrl = normalizedHash ? `${LOCAL_GATEWAY}${normalizedHash}` : '';\n          console.log(`Constructed URL from hash: ${downloadUrl}`);\n        }\n\n        // Create a temporary anchor element to trigger download\n        const link = document.createElement('a');\n        link.href = downloadUrl;\n        link.setAttribute('download', `image-${imageId}.jpg`);\n        link.setAttribute('target', '_blank');\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n        console.log(`Download initiated for image ${imageId} using fallback method`);\n      }\n    } catch (err) {\n      console.error('Failed to download image:', err);\n      alert('Failed to download image. Please try again later.');\n    } finally {\n      setImageLoadingStates(prev => ({\n        ...prev,\n        [imageId]: false\n      }));\n    }\n  };\n\n  // Memoize the refresh image handler to prevent recreation on each render\n  const handleRefreshImage = useCallback(async image => {\n    // Skip if component is unmounted\n    if (!isMounted.current) return;\n\n    // Set loading state\n    setImageLoadingStates(prev => ({\n      ...prev,\n      [image.id]: true\n    }));\n\n    // Create an AbortController for this operation\n    const controller = new AbortController();\n    const {\n      signal\n    } = controller;\n\n    // Set a timeout to abort the request if it takes too long\n    const timeoutId = setTimeout(() => {\n      controller.abort();\n      console.log(`Refresh timeout for image ${image.id}`);\n\n      // Reset loading state if component is still mounted\n      if (isMounted.current) {\n        setImageLoadingStates(prev => ({\n          ...prev,\n          [image.id]: false\n        }));\n      }\n    }, 10000); // 10 second timeout\n\n    try {\n      // Attempt to refresh the image by getting a new download link\n      await getImageDownloadLink(image.id);\n\n      // Skip further processing if component unmounted or request was aborted\n      if (!isMounted.current || signal.aborted) return;\n      console.log(`Successfully refreshed image ${image.id}`);\n\n      // Force reload the image by updating its src\n      const imgElement = document.getElementById(`img-${image.id}`);\n      if (imgElement) {\n        const currentSrc = imgElement.src;\n        imgElement.src = '';\n        // Add a cache-busting parameter\n        imgElement.src = `${currentSrc}${currentSrc.includes('?') ? '&' : '?'}t=${Date.now()}`;\n      }\n    } catch (err) {\n      // Skip error handling if component unmounted or request was aborted\n      if (!isMounted.current || signal.aborted) return;\n      if (err.name === 'AbortError') {\n        console.log(`Refresh aborted for image ${image.id}`);\n      } else {\n        console.error(`Error refreshing image ${image.id}:`, err);\n      }\n    } finally {\n      // Clear the timeout\n      clearTimeout(timeoutId);\n\n      // Only update state if component is still mounted and request wasn't aborted\n      if (isMounted.current && !signal.aborted) {\n        setImageLoadingStates(prev => ({\n          ...prev,\n          [image.id]: false\n        }));\n      }\n    }\n  }, [getImageDownloadLink]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(Navbar, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 451,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"container\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"card\",\n        children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n          children: [\"Welcome, \", user === null || user === void 0 ? void 0 : user.username, \"!\"]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 455,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n          children: [\"Role: \", user === null || user === void 0 ? void 0 : user.role]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 456,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            marginTop: '20px'\n          },\n          children: [/*#__PURE__*/_jsxDEV(Link, {\n            to: \"/upload\",\n            className: \"btn\",\n            children: \"Upload New Image\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 459,\n            columnNumber: 13\n          }, this), (user === null || user === void 0 ? void 0 : user.role) === 'admin' && /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 458,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 454,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"h3\", {\n        style: {\n          marginTop: '30px'\n        },\n        children: \"My Images\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 470,\n        columnNumber: 9\n      }, this), loading && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"spinner\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 473,\n        columnNumber: 11\n      }, this), error && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"alert alert-danger\",\n        children: error\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 477,\n        columnNumber: 11\n      }, this), !loading && myImages.length === 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"card\",\n        children: /*#__PURE__*/_jsxDEV(\"p\", {\n          children: \"You haven't uploaded any images yet.\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 482,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 481,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"image-grid\",\n        style: {\n          marginBottom: '20px'\n        },\n        children: myImages.map(image => /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"image-card\",\n          children: [/*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              position: 'relative'\n            },\n            children: [imageLoadingStates[image.id] ? /*#__PURE__*/_jsxDEV(\"div\", {\n              style: {\n                width: '100%',\n                height: '200px',\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center',\n                backgroundColor: '#f0f0f0',\n                borderTopLeftRadius: '8px',\n                borderTopRightRadius: '8px'\n              },\n              children: /*#__PURE__*/_jsxDEV(\"div\", {\n                className: \"spinner\",\n                style: {\n                  width: '40px',\n                  height: '40px'\n                }\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 503,\n                columnNumber: 21\n              }, this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 491,\n              columnNumber: 19\n            }, this) : /*#__PURE__*/_jsxDEV(\"img\", {\n              id: `img-${image.id}`,\n              src: `/api/images/download-file/${image.id}/?t=${Date.now()}`,\n              alt: `ID: ${image.id}`,\n              style: {\n                width: '100%',\n                height: '200px',\n                objectFit: 'cover',\n                borderTopLeftRadius: '8px',\n                borderTopRightRadius: '8px'\n              },\n              onError: e => {\n                console.log(`Image ${image.id} failed to load from cached URL, trying fallback...`);\n\n                // Skip if component is unmounted\n                if (!isMounted.current) return;\n\n                // Check if this is an authentication error (401)\n                if (e.target.src.includes('/api/images/download-file/')) {\n                  // First try to refresh the token\n                  const refreshToken = localStorage.getItem('refresh_token');\n                  if (refreshToken) {\n                    console.log(`Attempting to refresh token for image ${image.id}`);\n\n                    // Set loading state\n                    setImageLoadingStates(prev => ({\n                      ...prev,\n                      [image.id]: true\n                    }));\n\n                    // Use the API client's token refresh mechanism\n                    fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:8000'}/api/auth/token/refresh/`, {\n                      method: 'POST',\n                      headers: {\n                        'Content-Type': 'application/json'\n                      },\n                      body: JSON.stringify({\n                        refresh: refreshToken\n                      })\n                    }).then(response => response.json()).then(data => {\n                      if (data.access) {\n                        // Update the token in localStorage\n                        localStorage.setItem('access_token', data.access);\n                        console.log(`Token refreshed successfully for image ${image.id}`);\n\n                        // Retry loading the image with the new token\n                        setTimeout(() => {\n                          if (isMounted.current) {\n                            // Force reload with new timestamp to bypass cache\n                            e.target.src = `/api/images/download-file/${image.id}/?t=${Date.now()}`;\n                          }\n                        }, 300);\n                      } else {\n                        console.error(`Failed to refresh token for image ${image.id}`);\n                        // Try the fallback URL (IPFS gateway)\n                        const urls = getIpfsUrl(image.ipfs_hash, image.id);\n                        e.target.src = urls.primary;\n                      }\n                    }).catch(error => {\n                      console.error(`Error refreshing token for image ${image.id}:`, error);\n                      // Try the fallback URL (IPFS gateway)\n                      const urls = getIpfsUrl(image.ipfs_hash, image.id);\n                      e.target.src = urls.primary;\n                    }).finally(() => {\n                      if (isMounted.current) {\n                        setImageLoadingStates(prev => ({\n                          ...prev,\n                          [image.id]: false\n                        }));\n                      }\n                    });\n                  } else {\n                    // No refresh token available, try fallback URL\n                    console.log(`No refresh token available for image ${image.id}, using fallback URL`);\n                    const urls = getIpfsUrl(image.ipfs_hash, image.id);\n                    e.target.src = urls.primary;\n                  }\n                } else {\n                  // Not a backend URL, try other fallbacks\n                  const urls = getIpfsUrl(image.ipfs_hash, image.id);\n                  if (e.target.src !== urls.fallback && e.target.src !== urls.primary) {\n                    console.log(`Switching to fallback URL for image ${image.id}`);\n                    e.target.src = urls.fallback;\n                  } else {\n                    console.log(`All URLs failed for image ${image.id}`);\n\n                    // Set loading state\n                    setImageLoadingStates(prev => ({\n                      ...prev,\n                      [image.id]: true\n                    }));\n\n                    // Add a small delay before attempting recovery to prevent rapid retries\n                    setTimeout(() => {\n                      // Check again if component is still mounted\n                      if (isMounted.current) {\n                        // Call the refresh image function to attempt recovery\n                        handleRefreshImage(image);\n                      }\n                    }, 500);\n                  }\n                }\n              }\n              // Add cache-busting parameter to force reload\n            }, `img-${image.id}-${Date.now()}`, false, {\n              fileName: _jsxFileName,\n              lineNumber: 506,\n              columnNumber: 19\n            }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n              style: {\n                position: 'absolute',\n                top: '5px',\n                right: '5px',\n                background: 'rgba(255, 255, 255, 0.7)',\n                border: 'none',\n                borderRadius: '50%',\n                width: '30px',\n                height: '30px',\n                cursor: 'pointer',\n                display: 'flex',\n                alignItems: 'center',\n                justifyContent: 'center'\n              },\n              onClick: () => handleRefreshImage(image),\n              title: \"Refresh image\",\n              disabled: imageLoadingStates[image.id],\n              children: imageLoadingStates[image.id] ? '⌛' : '↻'\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 607,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 489,\n            columnNumber: 15\n          }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"image-info\",\n            children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n              children: [\"Image #\", image.id]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 631,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n              children: [\"Hash: \", image.sha256_hash.substring(0, 10), \"...\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 632,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n              children: [\"Uploaded: \", new Date(image.uploaded_at).toLocaleString()]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 633,\n              columnNumber: 17\n            }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n              children: [\"Deepfake: \", image.deepfake_label, \" (\", Math.round(image.deepfake_confidence * 100), \"%)\"]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 634,\n              columnNumber: 17\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 630,\n            columnNumber: 15\n          }, this)]\n        }, image.id, true, {\n          fileName: _jsxFileName,\n          lineNumber: 488,\n          columnNumber: 13\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 486,\n        columnNumber: 9\n      }, this), !loading && myImages.length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"pagination-controls\",\n        style: {\n          display: 'flex',\n          justifyContent: 'center',\n          alignItems: 'center',\n          margin: '20px 0 40px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"btn\",\n          onClick: previousPage,\n          disabled: !pagination.hasPrevious,\n          style: {\n            margin: '0 5px',\n            opacity: pagination.hasPrevious ? 1 : 0.5,\n            cursor: pagination.hasPrevious ? 'pointer' : 'not-allowed'\n          },\n          children: \"\\xAB Previous\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 648,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            margin: '0 15px'\n          },\n          children: Array.from({\n            length: pagination.totalPages\n          }, (_, i) => i + 1).map(page => /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => goToPage(page),\n            style: {\n              margin: '0 5px',\n              padding: '5px 10px',\n              border: page === pagination.currentPage ? '2px solid #007bff' : '1px solid #ccc',\n              borderRadius: '4px',\n              background: page === pagination.currentPage ? '#e6f2ff' : 'white',\n              cursor: 'pointer'\n            },\n            children: page\n          }, page, false, {\n            fileName: _jsxFileName,\n            lineNumber: 664,\n            columnNumber: 17\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 661,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"btn\",\n          onClick: nextPage,\n          disabled: !pagination.hasNext,\n          style: {\n            margin: '0 5px',\n            opacity: pagination.hasNext ? 1 : 0.5,\n            cursor: pagination.hasNext ? 'pointer' : 'not-allowed'\n          },\n          children: \"Next \\xBB\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 681,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 642,\n        columnNumber: 11\n      }, this), !loading && myImages.length > 0 && /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          textAlign: 'center',\n          marginBottom: '30px',\n          color: '#666'\n        },\n        children: [\"Showing page \", pagination.currentPage, \" of \", pagination.totalPages, \" (\", pagination.totalImages, \" total images)\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 698,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 453,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 450,\n    columnNumber: 5\n  }, this);\n};\n_s(Dashboard, \"GOXQCzhehB16O7KS/4JoS+70i+w=\", false, function () {\n  return [useAuth, useImages];\n});\n_c = Dashboard;\nexport default Dashboard;\nvar _c;\n$RefreshReg$(_c, \"Dashboard\");","map":{"version":3,"names":["React","useEffect","useState","useCallback","useMemo","Link","useAuth","useImages","Navbar","normalizeIpfsHash","jsxDEV","_jsxDEV","Fragment","_Fragment","LOCAL_GATEWAY","getIpfsUrl","hash","imageId","normalizedHash","localUrl","backendUrl","primary","fallback","Dashboard","_s","user","myImages","loading","error","pagination","getMyImages","getImageDownloadLink","downloadImageFile","nextPage","previousPage","goToPage","imageLoadingStates","setImageLoadingStates","requestQueue","useRef","queue","running","maxConcurrent","maxRetries","abortControllers","Map","add","fn","priority","retryCount","id","Date","now","toString","isMounted","current","queueItem","controller","AbortController","set","unshift","push","processQueue","length","shift","has","get","signal","aborted","delete","name","console","log","backoffDelay","Math","min","pow","setTimeout","abort","clear","forEach","e","currentQueue","preloadImage","image","abortSignal","prev","timeoutPromise","Promise","_","reject","clearTimeout","Error","race","err","initialLoadRef","currentPage","pageSize","timeoutId","response","images","results","preloadedImages","Set","requestIds","requestId","addEventListener","handleDownload","directResult","success","objectUrl","link","document","createElement","href","setAttribute","body","appendChild","click","removeChild","URL","revokeObjectURL","url","window","open","find","img","downloadUrl","data","ipfsUrls","local","ipfsUrl","ipfsHash","ipfs_hash","alert","handleRefreshImage","imgElement","getElementById","currentSrc","src","includes","children","fileName","_jsxFileName","lineNumber","columnNumber","className","username","role","style","marginTop","to","marginBottom","map","position","width","height","display","alignItems","justifyContent","backgroundColor","borderTopLeftRadius","borderTopRightRadius","alt","objectFit","onError","target","refreshToken","localStorage","getItem","fetch","process","env","REACT_APP_API_URL","method","headers","JSON","stringify","refresh","then","json","access","setItem","urls","catch","finally","top","right","background","border","borderRadius","cursor","onClick","title","disabled","sha256_hash","substring","uploaded_at","toLocaleString","deepfake_label","round","deepfake_confidence","margin","hasPrevious","opacity","Array","from","totalPages","i","page","padding","hasNext","textAlign","color","totalImages","_c","$RefreshReg$"],"sources":["C:/Users/Erwachens/Desktop/MyProject/frontend/src/pages/Dashboard.jsx"],"sourcesContent":["import React, { useEffect, useState, useCallback, useMemo } from 'react';\r\nimport { Link } from 'react-router-dom';\r\nimport { useAuth } from '../context/AuthContext';\r\nimport { useImages } from '../context/ImageContext';\r\nimport Navbar from '../components/common/Navbar';\r\nimport { normalizeIpfsHash } from '../util/ipfs';\r\n\r\n// Local IPFS gateway URL\r\nconst LOCAL_GATEWAY = 'http://127.0.0.1:8080/ipfs/';\r\n\r\n// Function to get IPFS URL from hash with multiple fallback options\r\nconst getIpfsUrl = (hash, imageId) => {\r\n  // First try to normalize the hash\r\n  const normalizedHash = normalizeIpfsHash(hash);\r\n  if (!normalizedHash) return '';\r\n  \r\n  // Primary URL: Local gateway\r\n  const localUrl = `${LOCAL_GATEWAY}${normalizedHash}`;\r\n  \r\n  // Fallback URL: Direct backend download endpoint\r\n  const backendUrl = `/api/images/download-file/${imageId}/`;\r\n  \r\n  // Return both URLs for fallback mechanism\r\n  return {\r\n    primary: localUrl,\r\n    fallback: backendUrl\r\n  };\r\n};\r\n\r\nconst Dashboard = () => {\r\n  const { user } = useAuth();\r\n  const { \r\n    myImages, \r\n    loading, \r\n    error, \r\n    pagination,\r\n    getMyImages, \r\n    getImageDownloadLink,\r\n    downloadImageFile,\r\n    nextPage,\r\n    previousPage,\r\n    goToPage\r\n  } = useImages();\r\n\r\n  // Add state to track loading status of individual images\r\n  const [imageLoadingStates, setImageLoadingStates] = useState({});\r\n\r\n  // Enhanced queue for limiting concurrent API requests with retry and backoff\r\n  const requestQueue = React.useRef({\r\n    queue: [],\r\n    running: 0,\r\n    maxConcurrent: 2, // Limit to 2 concurrent requests\r\n    maxRetries: 3,    // Maximum number of retries per request\r\n    abortControllers: new Map(), // Track abort controllers for each request\r\n    \r\n    add(fn, priority = false, retryCount = 0, id = Date.now().toString()) {\r\n      // Skip adding if component is unmounted\r\n      if (!isMounted.current) return;\r\n      \r\n      const queueItem = { fn, retryCount, id };\r\n      \r\n      // Create an AbortController for this request\r\n      const controller = new AbortController();\r\n      this.abortControllers.set(id, controller);\r\n      \r\n      // Add high priority items to the front of the queue\r\n      if (priority) {\r\n        this.queue.unshift(queueItem);\r\n      } else {\r\n        this.queue.push(queueItem);\r\n      }\r\n      \r\n      this.processQueue();\r\n      \r\n      // Return the request ID so it can be aborted later if needed\r\n      return id;\r\n    },\r\n    \r\n    async processQueue() {\r\n      if (this.running >= this.maxConcurrent || this.queue.length === 0 || !isMounted.current) {\r\n        return;\r\n      }\r\n      \r\n      this.running++;\r\n      const { fn, retryCount, id } = this.queue.shift();\r\n      \r\n      // Skip if component is unmounted or this specific request was aborted\r\n      if (!isMounted.current || (this.abortControllers.has(id) && this.abortControllers.get(id).signal.aborted)) {\r\n        this.running--;\r\n        this.abortControllers.delete(id);\r\n        this.processQueue();\r\n        return;\r\n      }\r\n      \r\n      try {\r\n        // Get the abort controller for this request\r\n        const controller = this.abortControllers.get(id);\r\n        \r\n        // Pass the abort signal to the function if it accepts it\r\n        await fn(controller?.signal);\r\n      } catch (error) {\r\n        // Check if the error is due to abortion\r\n        if (error.name === 'AbortError') {\r\n          console.log(`Request ${id} was aborted`);\r\n        } else {\r\n          console.error(\"Error in queue processing:\", error);\r\n          \r\n          // Only retry if the component is still mounted and we haven't exceeded max retries\r\n          if (isMounted.current && retryCount < this.maxRetries) {\r\n            console.log(`Retrying request (attempt ${retryCount + 1} of ${this.maxRetries})...`);\r\n            \r\n            // Calculate backoff delay: 2^retryCount * 1000ms (1s, 2s, 4s, etc.)\r\n            const backoffDelay = Math.min(Math.pow(2, retryCount) * 1000, 10000);\r\n            \r\n            setTimeout(() => {\r\n              if (isMounted.current) {\r\n                // Re-add the failed request to the queue with increased retry count\r\n                this.add(fn, false, retryCount + 1, id);\r\n              }\r\n            }, backoffDelay);\r\n          }\r\n        }\r\n      } finally {\r\n        this.running--;\r\n        this.abortControllers.delete(id);\r\n        \r\n        // Only continue processing if component is still mounted\r\n        if (isMounted.current) {\r\n          // Add a small delay between requests to prevent overwhelming the server\r\n          setTimeout(() => {\r\n            this.processQueue();\r\n          }, 100);\r\n        }\r\n      }\r\n    },\r\n    \r\n    // Abort a specific request\r\n    abort(id) {\r\n      if (this.abortControllers.has(id)) {\r\n        this.abortControllers.get(id).abort();\r\n        this.abortControllers.delete(id);\r\n      }\r\n    },\r\n    \r\n    // Clear the queue and abort all pending requests\r\n    clear() {\r\n      // Abort all pending requests\r\n      this.abortControllers.forEach(controller => {\r\n        try {\r\n          controller.abort();\r\n        } catch (e) {\r\n          console.error(\"Error aborting request:\", e);\r\n        }\r\n      });\r\n      \r\n      this.queue = [];\r\n      this.abortControllers.clear();\r\n    }\r\n  });\r\n\r\n  // Reference to track if the component is mounted\r\n  const isMounted = React.useRef(true);\r\n  \r\n  // Clear the request queue when component unmounts\r\n  useEffect(() => {\r\n    // Store a reference to the current queue for cleanup\r\n    const currentQueue = requestQueue.current;\r\n    \r\n    return () => {\r\n      isMounted.current = false;\r\n      currentQueue.clear();\r\n    };\r\n  }, []);\r\n  \r\n  // Create a memoized version of the preload function to avoid recreating it on every render\r\n  const preloadImage = useCallback(async (image, abortSignal) => {\r\n    if (!isMounted.current) return;\r\n    \r\n    setImageLoadingStates(prev => ({ ...prev, [image.id]: true }));\r\n    try {\r\n      // Create a timeout promise that rejects after a certain time\r\n      const timeoutPromise = new Promise((_, reject) => {\r\n        const id = setTimeout(() => {\r\n          clearTimeout(id);\r\n          reject(new Error(`Preload timeout for image ${image.id}`));\r\n        }, 15000); // 15 second timeout\r\n      });\r\n      \r\n      // Race the actual request against the timeout\r\n      await Promise.race([\r\n        getImageDownloadLink(image.id),\r\n        timeoutPromise\r\n      ]);\r\n      \r\n      // Check if component is still mounted or if the request was aborted\r\n      if (!isMounted.current || (abortSignal && abortSignal.aborted)) return;\r\n      \r\n      console.log(`Preloaded image ${image.id}`);\r\n    } catch (err) {\r\n      // Check if component is still mounted or if the request was aborted\r\n      if (!isMounted.current || (abortSignal && abortSignal.aborted)) return;\r\n      \r\n      // Check if it's an abort error\r\n      if (err.name === 'AbortError') {\r\n        console.log(`Preload aborted for image ${image.id}`);\r\n      } else {\r\n        console.error(`Failed to preload image ${image.id}:`, err);\r\n      }\r\n    } finally {\r\n      // Only update state if component is still mounted and request wasn't aborted\r\n      if (isMounted.current && !(abortSignal && abortSignal.aborted)) {\r\n        setImageLoadingStates(prev => ({ ...prev, [image.id]: false }));\r\n      }\r\n    }\r\n  }, [getImageDownloadLink]);\r\n\r\n  // Track if initial load has happened\r\n  const initialLoadRef = React.useRef(false);\r\n  \r\n  // Fetch user's images when component mounts or pagination changes\r\n  useEffect(() => {\r\n    // Skip if this is just a re-render and not a pagination change\r\n    if (initialLoadRef.current && \r\n        pagination.currentPage === 1 && \r\n        pagination.pageSize === 9 && \r\n        myImages.length > 0) {\r\n      return;\r\n    }\r\n    \r\n    // Set initial load flag\r\n    initialLoadRef.current = true;\r\n    \r\n    // Create an AbortController for this effect\r\n    const controller = new AbortController();\r\n    const { signal } = controller;\r\n    \r\n    // Use a debounce mechanism to prevent multiple rapid calls\r\n    const timeoutId = setTimeout(async () => {\r\n      if (!isMounted.current || signal.aborted) return;\r\n      \r\n      try {\r\n        // Load the current page of images with abort signal\r\n        const response = await getMyImages(pagination.currentPage, pagination.pageSize);\r\n        if (!isMounted.current || signal.aborted) return;\r\n        \r\n        const images = response.results || [];\r\n        console.log(`Loaded ${images.length} images for page ${pagination.currentPage}`);\r\n        \r\n        // Create a Set to track which images we've already started preloading\r\n        const preloadedImages = new Set();\r\n        \r\n        // Store request IDs for cleanup\r\n        const requestIds = [];\r\n        \r\n        // Preload images sequentially using the request queue to limit concurrent requests\r\n        // Only preload visible images to reduce unnecessary requests\r\n        images.forEach(image => {\r\n          if (!isMounted.current || signal.aborted) return;\r\n          \r\n          // Skip if we've already started preloading this image\r\n          if (preloadedImages.has(image.id)) {\r\n            return;\r\n          }\r\n          \r\n          // Mark this image as being preloaded\r\n          preloadedImages.add(image.id);\r\n          \r\n          // Add to queue and store request ID\r\n          const requestId = requestQueue.current.add(async (abortSignal) => {\r\n            await preloadImage(image, abortSignal);\r\n          });\r\n          \r\n          if (requestId) {\r\n            requestIds.push(requestId);\r\n          }\r\n        });\r\n        \r\n        // Add cleanup for these specific requests\r\n        signal.addEventListener('abort', () => {\r\n          requestIds.forEach(id => requestQueue.current.abort(id));\r\n        });\r\n        \r\n      } catch (err) {\r\n        if (!isMounted.current || signal.aborted) return;\r\n        \r\n        if (err.name === 'AbortError') {\r\n          console.log('Image loading aborted');\r\n        } else {\r\n          console.error('Failed to load images:', err);\r\n        }\r\n      }\r\n    }, 300); // 300ms debounce delay\r\n    \r\n    // Cleanup function to cancel any pending operations if the dependencies change\r\n    return () => {\r\n      clearTimeout(timeoutId);\r\n      controller.abort();\r\n    };\r\n  }, [\r\n    pagination.currentPage,\r\n    pagination.pageSize,\r\n    getMyImages,\r\n    preloadImage,\r\n    myImages.length\r\n  ]);\r\n\r\n  // eslint-disable-next-line no-unused-vars\r\n  const handleDownload = async (imageId) => {\r\n    try {\r\n      // First try the direct download method\r\n      console.log(`Attempting direct download for image ${imageId}`);\r\n      setImageLoadingStates(prev => ({ ...prev, [imageId]: true }));\r\n      \r\n      const directResult = await downloadImageFile(imageId);\r\n      \r\n      if (directResult.success) {\r\n        console.log(`Direct download successful for image ${imageId}`);\r\n        \r\n        // If we got an objectUrl (blob), create a download link\r\n        if (directResult.objectUrl) {\r\n          // Create a temporary anchor element to trigger download\r\n          const link = document.createElement('a');\r\n          link.href = directResult.objectUrl;\r\n          link.setAttribute('download', `image-${imageId}.jpg`);\r\n          document.body.appendChild(link);\r\n          link.click();\r\n          document.body.removeChild(link);\r\n          \r\n          // Clean up the object URL to avoid memory leaks\r\n          setTimeout(() => URL.revokeObjectURL(directResult.objectUrl), 100);\r\n          \r\n          console.log(`Download initiated for image ${imageId} using blob`);\r\n        } \r\n        // If we got a fallback URL, open it in a new tab\r\n        else if (directResult.url) {\r\n          window.open(directResult.url, '_blank');\r\n          console.log(`Download initiated for image ${imageId} using fallback URL`);\r\n        }\r\n      } else {\r\n        // If direct download failed, fall back to the old method\r\n        console.log(`Direct download failed for image ${imageId}, falling back to link method`);\r\n        \r\n        const response = await getImageDownloadLink(imageId);\r\n        console.log(`Download link response for image ${imageId}:`, response);\r\n        \r\n        // Get the image from our state\r\n        const image = myImages.find(img => img.id === imageId);\r\n        if (!image) {\r\n          console.error(`Image ${imageId} not found in state`);\r\n          return;\r\n        }\r\n        \r\n        // Get the best available URL (local or public)\r\n        let downloadUrl;\r\n        if (response.data && response.data.ipfsUrls && response.data.ipfsUrls.local) {\r\n          downloadUrl = response.data.ipfsUrls.local;\r\n          console.log(`Using local URL from response: ${downloadUrl}`);\r\n        } else if (response.data && response.data.ipfsUrl) {\r\n          // Fallback to the original URL if the new structure isn't available\r\n          downloadUrl = response.data.ipfsUrl;\r\n          console.log(`Using original URL from response: ${downloadUrl}`);\r\n        } else {\r\n          // If no URL is available, construct one from the hash using our utility\r\n          const hash = (response.data && response.data.ipfsHash) || image.ipfs_hash;\r\n          const normalizedHash = normalizeIpfsHash(hash);\r\n          downloadUrl = normalizedHash ? `${LOCAL_GATEWAY}${normalizedHash}` : '';\r\n          console.log(`Constructed URL from hash: ${downloadUrl}`);\r\n        }\r\n        \r\n        // Create a temporary anchor element to trigger download\r\n        const link = document.createElement('a');\r\n        link.href = downloadUrl;\r\n        link.setAttribute('download', `image-${imageId}.jpg`);\r\n        link.setAttribute('target', '_blank');\r\n        document.body.appendChild(link);\r\n        link.click();\r\n        document.body.removeChild(link);\r\n        \r\n        console.log(`Download initiated for image ${imageId} using fallback method`);\r\n      }\r\n    } catch (err) {\r\n      console.error('Failed to download image:', err);\r\n      alert('Failed to download image. Please try again later.');\r\n    } finally {\r\n      setImageLoadingStates(prev => ({ ...prev, [imageId]: false }));\r\n    }\r\n  };\r\n\r\n  // Memoize the refresh image handler to prevent recreation on each render\r\n  const handleRefreshImage = useCallback(async (image) => {\r\n    // Skip if component is unmounted\r\n    if (!isMounted.current) return;\r\n    \r\n    // Set loading state\r\n    setImageLoadingStates(prev => ({ ...prev, [image.id]: true }));\r\n    \r\n    // Create an AbortController for this operation\r\n    const controller = new AbortController();\r\n    const { signal } = controller;\r\n    \r\n    // Set a timeout to abort the request if it takes too long\r\n    const timeoutId = setTimeout(() => {\r\n      controller.abort();\r\n      console.log(`Refresh timeout for image ${image.id}`);\r\n      \r\n      // Reset loading state if component is still mounted\r\n      if (isMounted.current) {\r\n        setImageLoadingStates(prev => ({ ...prev, [image.id]: false }));\r\n      }\r\n    }, 10000); // 10 second timeout\r\n    \r\n    try {\r\n      // Attempt to refresh the image by getting a new download link\r\n      await getImageDownloadLink(image.id);\r\n      \r\n      // Skip further processing if component unmounted or request was aborted\r\n      if (!isMounted.current || signal.aborted) return;\r\n      \r\n      console.log(`Successfully refreshed image ${image.id}`);\r\n      \r\n      // Force reload the image by updating its src\r\n      const imgElement = document.getElementById(`img-${image.id}`);\r\n      if (imgElement) {\r\n        const currentSrc = imgElement.src;\r\n        imgElement.src = '';\r\n        // Add a cache-busting parameter\r\n        imgElement.src = `${currentSrc}${currentSrc.includes('?') ? '&' : '?'}t=${Date.now()}`;\r\n      }\r\n    } catch (err) {\r\n      // Skip error handling if component unmounted or request was aborted\r\n      if (!isMounted.current || signal.aborted) return;\r\n      \r\n      if (err.name === 'AbortError') {\r\n        console.log(`Refresh aborted for image ${image.id}`);\r\n      } else {\r\n        console.error(`Error refreshing image ${image.id}:`, err);\r\n      }\r\n    } finally {\r\n      // Clear the timeout\r\n      clearTimeout(timeoutId);\r\n      \r\n      // Only update state if component is still mounted and request wasn't aborted\r\n      if (isMounted.current && !signal.aborted) {\r\n        setImageLoadingStates(prev => ({ ...prev, [image.id]: false }));\r\n      }\r\n    }\r\n  }, [getImageDownloadLink]);\r\n\r\n  return (\r\n    <div>\r\n      <Navbar />\r\n      \r\n      <div className=\"container\">\r\n        <div className=\"card\">\r\n          <h2>Welcome, {user?.username}!</h2>\r\n          <p>Role: {user?.role}</p>\r\n          \r\n          <div style={{ marginTop: '20px' }}>\r\n            <Link to=\"/upload\" className=\"btn\">Upload New Image</Link>\r\n            \r\n            \r\n\r\n            {user?.role === 'admin' && (\r\n              <>\r\n              </>\r\n            )}\r\n          </div>\r\n        </div>\r\n        \r\n        <h3 style={{ marginTop: '30px' }}>My Images</h3>\r\n        \r\n        {loading && (\r\n          <div className=\"spinner\"></div>\r\n        )}\r\n        \r\n        {error && (\r\n          <div className=\"alert alert-danger\">{error}</div>\r\n        )}\r\n        \r\n        {!loading && myImages.length === 0 && (\r\n          <div className=\"card\">\r\n            <p>You haven't uploaded any images yet.</p>\r\n          </div>\r\n        )}\r\n        \r\n        <div className=\"image-grid\" style={{ marginBottom: '20px' }}>\r\n          {myImages.map((image) => (\r\n            <div key={image.id} className=\"image-card\">\r\n              <div style={{ position: 'relative' }}>\r\n                {imageLoadingStates[image.id] ? (\r\n                  <div \r\n                    style={{ \r\n                      width: '100%', \r\n                      height: '200px',\r\n                      display: 'flex',\r\n                      alignItems: 'center',\r\n                      justifyContent: 'center',\r\n                      backgroundColor: '#f0f0f0',\r\n                      borderTopLeftRadius: '8px',\r\n                      borderTopRightRadius: '8px'\r\n                    }}\r\n                  >\r\n                    <div className=\"spinner\" style={{ width: '40px', height: '40px' }}></div>\r\n                  </div>\r\n                ) : (\r\n                  <img \r\n                    id={`img-${image.id}`}\r\n                    src={`/api/images/download-file/${image.id}/?t=${Date.now()}`}\r\n                    alt={`ID: ${image.id}`}\r\n                    style={{ \r\n                      width: '100%', \r\n                      height: '200px', \r\n                      objectFit: 'cover',\r\n                      borderTopLeftRadius: '8px',\r\n                      borderTopRightRadius: '8px'\r\n                    }}\r\n                    onError={(e) => {\r\n                      console.log(`Image ${image.id} failed to load from cached URL, trying fallback...`);\r\n                      \r\n                      // Skip if component is unmounted\r\n                      if (!isMounted.current) return;\r\n                      \r\n                      // Check if this is an authentication error (401)\r\n                      if (e.target.src.includes('/api/images/download-file/')) {\r\n                        // First try to refresh the token\r\n                        const refreshToken = localStorage.getItem('refresh_token');\r\n                        if (refreshToken) {\r\n                          console.log(`Attempting to refresh token for image ${image.id}`);\r\n                          \r\n                          // Set loading state\r\n                          setImageLoadingStates(prev => ({ ...prev, [image.id]: true }));\r\n                          \r\n                          // Use the API client's token refresh mechanism\r\n                          fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:8000'}/api/auth/token/refresh/`, {\r\n                            method: 'POST',\r\n                            headers: {\r\n                              'Content-Type': 'application/json',\r\n                            },\r\n                            body: JSON.stringify({ refresh: refreshToken }),\r\n                          })\r\n                          .then(response => response.json())\r\n                          .then(data => {\r\n                            if (data.access) {\r\n                              // Update the token in localStorage\r\n                              localStorage.setItem('access_token', data.access);\r\n                              console.log(`Token refreshed successfully for image ${image.id}`);\r\n                              \r\n                              // Retry loading the image with the new token\r\n                              setTimeout(() => {\r\n                                if (isMounted.current) {\r\n                                  // Force reload with new timestamp to bypass cache\r\n                                  e.target.src = `/api/images/download-file/${image.id}/?t=${Date.now()}`;\r\n                                }\r\n                              }, 300);\r\n                            } else {\r\n                              console.error(`Failed to refresh token for image ${image.id}`);\r\n                              // Try the fallback URL (IPFS gateway)\r\n                              const urls = getIpfsUrl(image.ipfs_hash, image.id);\r\n                              e.target.src = urls.primary;\r\n                            }\r\n                          })\r\n                          .catch(error => {\r\n                            console.error(`Error refreshing token for image ${image.id}:`, error);\r\n                            // Try the fallback URL (IPFS gateway)\r\n                            const urls = getIpfsUrl(image.ipfs_hash, image.id);\r\n                            e.target.src = urls.primary;\r\n                          })\r\n                          .finally(() => {\r\n                            if (isMounted.current) {\r\n                              setImageLoadingStates(prev => ({ ...prev, [image.id]: false }));\r\n                            }\r\n                          });\r\n                        } else {\r\n                          // No refresh token available, try fallback URL\r\n                          console.log(`No refresh token available for image ${image.id}, using fallback URL`);\r\n                          const urls = getIpfsUrl(image.ipfs_hash, image.id);\r\n                          e.target.src = urls.primary;\r\n                        }\r\n                      } else {\r\n                        // Not a backend URL, try other fallbacks\r\n                        const urls = getIpfsUrl(image.ipfs_hash, image.id);\r\n                        if (e.target.src !== urls.fallback && e.target.src !== urls.primary) {\r\n                          console.log(`Switching to fallback URL for image ${image.id}`);\r\n                          e.target.src = urls.fallback;\r\n                        } else {\r\n                          console.log(`All URLs failed for image ${image.id}`);\r\n                          \r\n                          // Set loading state\r\n                          setImageLoadingStates(prev => ({ ...prev, [image.id]: true }));\r\n                          \r\n                          // Add a small delay before attempting recovery to prevent rapid retries\r\n                          setTimeout(() => {\r\n                            // Check again if component is still mounted\r\n                            if (isMounted.current) {\r\n                              // Call the refresh image function to attempt recovery\r\n                              handleRefreshImage(image);\r\n                            }\r\n                          }, 500);\r\n                        }\r\n                      }\r\n                    }}\r\n                    // Add cache-busting parameter to force reload\r\n                    key={`img-${image.id}-${Date.now()}`}\r\n                  />\r\n                )}\r\n                {/* Add a refresh button to retry loading the image */}\r\n                <button \r\n                  style={{\r\n                    position: 'absolute',\r\n                    top: '5px',\r\n                    right: '5px',\r\n                    background: 'rgba(255, 255, 255, 0.7)',\r\n                    border: 'none',\r\n                    borderRadius: '50%',\r\n                    width: '30px',\r\n                    height: '30px',\r\n                    cursor: 'pointer',\r\n                    display: 'flex',\r\n                    alignItems: 'center',\r\n                    justifyContent: 'center'\r\n                  }}\r\n                  onClick={() => handleRefreshImage(image)}\r\n                  title=\"Refresh image\"\r\n                  disabled={imageLoadingStates[image.id]}\r\n                >\r\n                  {imageLoadingStates[image.id] ? '⌛' : '↻'}\r\n                </button>\r\n              </div>\r\n              \r\n              <div className=\"image-info\">\r\n                <h3>Image #{image.id}</h3>\r\n                <p>Hash: {image.sha256_hash.substring(0, 10)}...</p>\r\n                <p>Uploaded: {new Date(image.uploaded_at).toLocaleString()}</p>\r\n                <p>Deepfake: {image.deepfake_label} ({Math.round(image.deepfake_confidence * 100)}%)</p>\r\n              </div>\r\n            </div>\r\n          ))}\r\n        </div>\r\n        \r\n        {/* Pagination Controls */}\r\n        {!loading && myImages.length > 0 && (\r\n          <div className=\"pagination-controls\" style={{ \r\n            display: 'flex', \r\n            justifyContent: 'center', \r\n            alignItems: 'center', \r\n            margin: '20px 0 40px' \r\n          }}>\r\n            <button \r\n              className=\"btn\" \r\n              onClick={previousPage} \r\n              disabled={!pagination.hasPrevious}\r\n              style={{ \r\n                margin: '0 5px',\r\n                opacity: pagination.hasPrevious ? 1 : 0.5,\r\n                cursor: pagination.hasPrevious ? 'pointer' : 'not-allowed'\r\n              }}\r\n            >\r\n              &laquo; Previous\r\n            </button>\r\n            \r\n            <div style={{ margin: '0 15px' }}>\r\n              {/* Page numbers */}\r\n              {Array.from({ length: pagination.totalPages }, (_, i) => i + 1).map(page => (\r\n                <button\r\n                  key={page}\r\n                  onClick={() => goToPage(page)}\r\n                  style={{\r\n                    margin: '0 5px',\r\n                    padding: '5px 10px',\r\n                    border: page === pagination.currentPage ? '2px solid #007bff' : '1px solid #ccc',\r\n                    borderRadius: '4px',\r\n                    background: page === pagination.currentPage ? '#e6f2ff' : 'white',\r\n                    cursor: 'pointer'\r\n                  }}\r\n                >\r\n                  {page}\r\n                </button>\r\n              ))}\r\n            </div>\r\n            \r\n            <button \r\n              className=\"btn\" \r\n              onClick={nextPage} \r\n              disabled={!pagination.hasNext}\r\n              style={{ \r\n                margin: '0 5px',\r\n                opacity: pagination.hasNext ? 1 : 0.5,\r\n                cursor: pagination.hasNext ? 'pointer' : 'not-allowed'\r\n              }}\r\n            >\r\n              Next &raquo;\r\n            </button>\r\n          </div>\r\n        )}\r\n        \r\n        {/* Pagination Info */}\r\n        {!loading && myImages.length > 0 && (\r\n          <div style={{ textAlign: 'center', marginBottom: '30px', color: '#666' }}>\r\n            Showing page {pagination.currentPage} of {pagination.totalPages} ({pagination.totalImages} total images)\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Dashboard;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}