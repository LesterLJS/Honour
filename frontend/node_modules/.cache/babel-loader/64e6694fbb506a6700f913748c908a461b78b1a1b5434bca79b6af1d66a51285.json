{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Erwachens\\\\Desktop\\\\MyProject\\\\frontend\\\\src\\\\context\\\\ImageContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useCallback, useRef } from 'react';\nimport { uploadImage as apiUploadImage, getMyImages as apiGetMyImages, getAllImages as apiGetAllImages, deleteImage as apiDeleteImage } from '../api/images';\n\n// Create the context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ImageContext = /*#__PURE__*/createContext(null);\n\n// Custom hook to use the image context\nexport const useImages = () => {\n  _s();\n  return useContext(ImageContext);\n};\n_s(useImages, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const ImageProvider = ({\n  children\n}) => {\n  _s2();\n  const [myImages, setMyImages] = useState([]);\n  const [allImages, setAllImages] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [pagination, setPagination] = useState({\n    currentPage: 1,\n    totalPages: 1,\n    totalImages: 0,\n    pageSize: 9,\n    hasNext: false,\n    hasPrevious: false\n  });\n\n  // Cache for API requests\n  const requestCache = useRef({\n    myImages: {},\n    // Cache for getMyImages requests\n\n    cacheTimeout: 30000,\n    // Cache timeout in ms (30 seconds)\n\n    // Get cached data if available and not expired\n    get(cacheKey, type) {\n      const cache = this[type];\n      const cachedData = cache[cacheKey];\n      if (cachedData && Date.now() - cachedData.timestamp < this.cacheTimeout) {\n        console.log(`Using cached data for ${type} - ${cacheKey}`);\n        return cachedData.data;\n      }\n      return null;\n    },\n    // Store data in cache\n    set(cacheKey, data, type) {\n      this[type][cacheKey] = {\n        data,\n        timestamp: Date.now()\n      };\n    },\n    // Clear specific cache entry\n    clear(cacheKey, type) {\n      if (this[type][cacheKey]) {\n        delete this[type][cacheKey];\n      }\n    },\n    // Clear all cache\n    clearAll() {\n      this.myImages = {};\n    }\n  });\n\n  // Upload an image\n  const uploadImage = useCallback(async imageFile => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiUploadImage(imageFile);\n      // Add the new image to the myImages array\n      setMyImages(prevImages => [response.data, ...prevImages]);\n      return response.data;\n    } catch (err) {\n      var _err$response, _err$response$data;\n      setError(((_err$response = err.response) === null || _err$response === void 0 ? void 0 : (_err$response$data = _err$response.data) === null || _err$response$data === void 0 ? void 0 : _err$response$data.error) || 'Image upload failed');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Get a stable image URL that won't change between renders\n  const getImageUrl = useCallback(imageId => {\n    // If the imageId looks like an IPFS hash (starts with Qm), use the hash-based endpoint\n    if (typeof imageId === 'string' && (imageId.startsWith('Qm') || imageId.startsWith('b'))) {\n      // Create a URL without timestamp to allow browser caching\n      return `/api/images/download-file-by-hash/${imageId}/`;\n    } else {\n      // Otherwise, assume it's a numeric ID and use the ID-based endpoint\n      return `/api/images/download-file/${imageId}/`;\n    }\n  }, []);\n\n  // Directly download image file from IPFS through the backend\n  const downloadImageFile = useCallback(async imageId => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiDownloadImageFile(imageId);\n\n      // If we got a blob response, create an object URL for it\n      if (response.blob) {\n        const objectUrl = URL.createObjectURL(response.blob);\n        return {\n          success: true,\n          objectUrl,\n          contentType: response.contentType,\n          blob: response.blob\n        };\n      }\n      // If we got a URL fallback\n      else if (response.url) {\n        return {\n          success: true,\n          url: response.url,\n          hash: response.hash\n        };\n      }\n      // If we got an error\n      else {\n        setError(response.error || 'Failed to download image');\n        return {\n          success: false,\n          error: response.error || 'Failed to download image'\n        };\n      }\n    } catch (err) {\n      var _err$response2, _err$response2$data;\n      const errorMsg = ((_err$response2 = err.response) === null || _err$response2 === void 0 ? void 0 : (_err$response2$data = _err$response2.data) === null || _err$response2$data === void 0 ? void 0 : _err$response2$data.error) || 'Failed to download image';\n      setError(errorMsg);\n      return {\n        success: false,\n        error: errorMsg\n      };\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Admin: Get all images\n  const getAllImages = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiGetAllImages();\n      setAllImages(response.data);\n      return response.data;\n    } catch (err) {\n      var _err$response3, _err$response3$data;\n      setError(((_err$response3 = err.response) === null || _err$response3 === void 0 ? void 0 : (_err$response3$data = _err$response3.data) === null || _err$response3$data === void 0 ? void 0 : _err$response3$data.error) || 'Failed to fetch all images');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []); // Add comma here\n\n  // Admin: Delete an image\n  const deleteImage = useCallback(async imageId => {\n    setLoading(true);\n    setError(null);\n    try {\n      await apiDeleteImage(imageId);\n      // Remove the deleted image from state\n      setAllImages(prevImages => prevImages.filter(img => img.id !== imageId));\n      setMyImages(prevImages => prevImages.filter(img => img.id !== imageId));\n      return true;\n    } catch (err) {\n      var _err$response4, _err$response4$data;\n      setError(((_err$response4 = err.response) === null || _err$response4 === void 0 ? void 0 : (_err$response4$data = _err$response4.data) === null || _err$response4$data === void 0 ? void 0 : _err$response4$data.error) || 'Failed to delete image');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []); // Add comma here\n\n  // Context value\n  const value = {\n    myImages,\n    allImages,\n    loading,\n    error,\n    pagination,\n    uploadImage,\n    getMyImages,\n    getImageDownloadLink,\n    downloadImageFile,\n    getImageUrl,\n    getAllImages,\n    deleteImage,\n    nextPage,\n    previousPage,\n    goToPage\n  };\n  return /*#__PURE__*/_jsxDEV(ImageContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 210,\n    columnNumber: 10\n  }, this);\n};\n_s2(ImageProvider, \"d31GObSrd4AU7/fjeXKqL3lvlIc=\");\n_c = ImageProvider;\nexport default ImageContext;\nvar _c;\n$RefreshReg$(_c, \"ImageProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useCallback","useRef","uploadImage","apiUploadImage","getMyImages","apiGetMyImages","getAllImages","apiGetAllImages","deleteImage","apiDeleteImage","jsxDEV","_jsxDEV","ImageContext","useImages","_s","ImageProvider","children","_s2","myImages","setMyImages","allImages","setAllImages","loading","setLoading","error","setError","pagination","setPagination","currentPage","totalPages","totalImages","pageSize","hasNext","hasPrevious","requestCache","cacheTimeout","get","cacheKey","type","cache","cachedData","Date","now","timestamp","console","log","data","set","clear","clearAll","imageFile","response","prevImages","err","_err$response","_err$response$data","getImageUrl","imageId","startsWith","downloadImageFile","apiDownloadImageFile","blob","objectUrl","URL","createObjectURL","success","contentType","url","hash","_err$response2","_err$response2$data","errorMsg","_err$response3","_err$response3$data","filter","img","id","_err$response4","_err$response4$data","value","getImageDownloadLink","nextPage","previousPage","goToPage","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Erwachens/Desktop/MyProject/frontend/src/context/ImageContext.jsx"],"sourcesContent":["import React, { createContext, useState, useContext, useCallback, useRef } from 'react';\r\nimport { \r\n  uploadImage as apiUploadImage,\r\n  getMyImages as apiGetMyImages,\r\n\r\n\r\n\r\n  getAllImages as apiGetAllImages,\r\n  deleteImage as apiDeleteImage,\r\n\r\n} from '../api/images';\r\n\r\n// Create the context\r\nconst ImageContext = createContext(null);\r\n\r\n// Custom hook to use the image context\r\nexport const useImages = () => useContext(ImageContext);\r\n\r\nexport const ImageProvider = ({ children }) => {\r\n  const [myImages, setMyImages] = useState([]);\r\n  const [allImages, setAllImages] = useState([]);\r\n\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n  const [pagination, setPagination] = useState({\r\n    currentPage: 1,\r\n    totalPages: 1,\r\n    totalImages: 0,\r\n    pageSize: 9,\r\n    hasNext: false,\r\n    hasPrevious: false\r\n  });\r\n  \r\n  // Cache for API requests\r\n  const requestCache = useRef({\r\n    myImages: {}, // Cache for getMyImages requests\r\n\r\n    cacheTimeout: 30000, // Cache timeout in ms (30 seconds)\r\n    \r\n    // Get cached data if available and not expired\r\n    get(cacheKey, type) {\r\n      const cache = this[type];\r\n      const cachedData = cache[cacheKey];\r\n      \r\n      if (cachedData && Date.now() - cachedData.timestamp < this.cacheTimeout) {\r\n        console.log(`Using cached data for ${type} - ${cacheKey}`);\r\n        return cachedData.data;\r\n      }\r\n      \r\n      return null;\r\n    },\r\n    \r\n    // Store data in cache\r\n    set(cacheKey, data, type) {\r\n      this[type][cacheKey] = {\r\n        data,\r\n        timestamp: Date.now()\r\n      };\r\n    },\r\n    \r\n    // Clear specific cache entry\r\n    clear(cacheKey, type) {\r\n      if (this[type][cacheKey]) {\r\n        delete this[type][cacheKey];\r\n      }\r\n    },\r\n    \r\n    // Clear all cache\r\n    clearAll() {\r\n      this.myImages = {};\r\n\r\n    }\r\n  });\r\n\r\n  // Upload an image\r\n  const uploadImage = useCallback(async (imageFile) => {\r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      const response = await apiUploadImage(imageFile);\r\n      // Add the new image to the myImages array\r\n      setMyImages(prevImages => [response.data, ...prevImages]);\r\n      return response.data;\r\n    } catch (err) {\r\n      setError(err.response?.data?.error || 'Image upload failed');\r\n      throw err;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, []);\r\n\r\n\r\n  \r\n\r\n// Get a stable image URL that won't change between renders\r\nconst getImageUrl = useCallback((imageId) => {\r\n  // If the imageId looks like an IPFS hash (starts with Qm), use the hash-based endpoint\r\n  if (typeof imageId === 'string' && (imageId.startsWith('Qm') || imageId.startsWith('b'))) {\r\n    // Create a URL without timestamp to allow browser caching\r\n    return `/api/images/download-file-by-hash/${imageId}/`;\r\n  } else {\r\n    // Otherwise, assume it's a numeric ID and use the ID-based endpoint\r\n    return `/api/images/download-file/${imageId}/`;\r\n  }\r\n}, []);\r\n\r\n// Directly download image file from IPFS through the backend\r\nconst downloadImageFile = useCallback(async (imageId) => {\r\n  setLoading(true);\r\n  setError(null);\r\n  try {\r\n    const response = await apiDownloadImageFile(imageId);\r\n    \r\n    // If we got a blob response, create an object URL for it\r\n    if (response.blob) {\r\n      const objectUrl = URL.createObjectURL(response.blob);\r\n      return {\r\n        success: true,\r\n        objectUrl,\r\n        contentType: response.contentType,\r\n        blob: response.blob\r\n      };\r\n    } \r\n    // If we got a URL fallback\r\n    else if (response.url) {\r\n      return {\r\n        success: true,\r\n        url: response.url,\r\n        hash: response.hash\r\n      };\r\n    }\r\n    // If we got an error\r\n    else {\r\n      setError(response.error || 'Failed to download image');\r\n      return {\r\n        success: false,\r\n        error: response.error || 'Failed to download image'\r\n      };\r\n    }\r\n  } catch (err) {\r\n    const errorMsg = err.response?.data?.error || 'Failed to download image';\r\n    setError(errorMsg);\r\n    return {\r\n      success: false,\r\n      error: errorMsg\r\n    };\r\n  } finally {\r\n    setLoading(false);\r\n  }\r\n}, []);\r\n\r\n  \r\n// Admin: Get all images\r\nconst getAllImages = useCallback(async () => {\r\n  setLoading(true);\r\n  setError(null);\r\n  try {\r\n    const response = await apiGetAllImages();\r\n    setAllImages(response.data);\r\n    return response.data;\r\n  } catch (err) {\r\n    setError(err.response?.data?.error || 'Failed to fetch all images');\r\n    throw err;\r\n  } finally {\r\n    setLoading(false);\r\n  }\r\n}, []); // Add comma here\r\n\r\n// Admin: Delete an image\r\nconst deleteImage = useCallback(async (imageId) => {\r\n  setLoading(true);\r\n  setError(null);\r\n  try {\r\n    await apiDeleteImage(imageId);\r\n    // Remove the deleted image from state\r\n    setAllImages(prevImages => prevImages.filter(img => img.id !== imageId));\r\n    setMyImages(prevImages => prevImages.filter(img => img.id !== imageId));\r\n    return true;\r\n  } catch (err) {\r\n    setError(err.response?.data?.error || 'Failed to delete image');\r\n    throw err;\r\n  } finally {\r\n    setLoading(false);\r\n  }\r\n}, []); // Add comma here\r\n\r\n  \r\n  // Context value\r\n  const value = {\r\n    myImages,\r\n    allImages,\r\n    loading,\r\n    error,\r\n    pagination,\r\n    uploadImage,\r\n    \r\n    getMyImages,\r\n    getImageDownloadLink,\r\n    downloadImageFile,\r\n    getImageUrl,\r\n   \r\n    getAllImages,\r\n    deleteImage,\r\n    \r\n    nextPage,\r\n    previousPage,\r\n    goToPage,\r\n  };\r\n\r\n  return <ImageContext.Provider value={value}>{children}</ImageContext.Provider>;\r\n};\r\n\r\nexport default ImageContext;\r\n\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}