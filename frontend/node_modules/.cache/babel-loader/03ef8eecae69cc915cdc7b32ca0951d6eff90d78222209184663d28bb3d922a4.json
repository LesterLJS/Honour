{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Erwachens\\\\Desktop\\\\MyProject\\\\frontend\\\\src\\\\components\\\\images\\\\ImageWithAuth.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport api from '../../api';\nimport { normalizeIpfsHash } from '../../util/ipfs';\n\n// Local IPFS gateway URL\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst LOCAL_GATEWAY = 'http://127.0.0.1:8080/ipfs/';\n\n// Function to get IPFS URL from hash with multiple fallback options\nconst getIpfsUrl = (hash, imageId) => {\n  // First try to normalize the hash\n  const normalizedHash = normalizeIpfsHash(hash);\n  if (!normalizedHash) return '';\n\n  // Primary URL: Local gateway\n  const localUrl = `${LOCAL_GATEWAY}${normalizedHash}`;\n\n  // Fallback URL: Direct backend download endpoint\n  const backendUrl = `/api/images/download-file/${imageId}/`;\n\n  // Return both URLs for fallback mechanism\n  return {\n    primary: localUrl,\n    fallback: backendUrl\n  };\n};\n\n/**\r\n * Component for loading images with authentication\r\n * Uses axios interceptors to handle token refresh automatically\r\n */\nconst ImageWithAuth = ({\n  id,\n  imageId,\n  ipfsHash,\n  alt,\n  style,\n  onRefresh,\n  setLoading,\n  isMounted\n}) => {\n  _s();\n  const [imageSrc, setImageSrc] = useState('');\n  const [error, setError] = useState(false);\n  const imageRef = useRef(null);\n  const loadAttempts = useRef(0);\n\n  // Load the image using authenticated API request\n  const loadImage = async () => {\n    if (!isMounted.current) return;\n    try {\n      setLoading(true);\n      setError(false);\n\n      // Use axios with interceptors to handle authentication\n      // Remove cache-busting parameter to prevent request loops\n      const response = await api.get(`/api/images/download-file/${imageId}/`, {\n        responseType: 'blob'\n      });\n      if (!isMounted.current) return;\n\n      // Create an object URL from the blob\n      const objectUrl = URL.createObjectURL(response.data);\n      setImageSrc(objectUrl);\n\n      // Clean up the object URL when the component unmounts or when the src changes\n      return () => {\n        URL.revokeObjectURL(objectUrl);\n      };\n    } catch (err) {\n      if (!isMounted.current) return;\n      console.error(`Error loading image ${imageId}:`, err);\n      setError(true);\n\n      // Try fallback URL if available\n      if (ipfsHash) {\n        const urls = getIpfsUrl(ipfsHash, imageId);\n        setImageSrc(urls.primary);\n      }\n    } finally {\n      if (isMounted.current) {\n        setLoading(false);\n      }\n    }\n  };\n\n  // Load the image on mount and when imageId changes\n  useEffect(() => {\n    loadAttempts.current = 0;\n\n    // Track if component is mounted\n    isMounted.current = true;\n\n    // Create a variable to store the cleanup function\n    let cleanupFunction = null;\n    const loadAndSetupCleanup = async () => {\n      try {\n        // Call loadImage and store the cleanup function\n        const cleanup = await loadImage();\n\n        // Only store the cleanup if component is still mounted\n        if (isMounted.current && typeof cleanup === 'function') {\n          cleanupFunction = cleanup;\n        }\n      } catch (err) {\n        console.error('Error in loadImage:', err);\n      }\n    };\n\n    // Start the loading process\n    loadAndSetupCleanup();\n\n    // Clean up function\n    return () => {\n      // Mark component as unmounted\n      isMounted.current = false;\n\n      // Call the cleanup function if it exists\n      if (typeof cleanupFunction === 'function') {\n        try {\n          cleanupFunction();\n        } catch (err) {\n          console.error('Error in cleanup function:', err);\n        }\n      }\n    };\n  }, [imageId]);\n\n  // Handle image load error\n  const handleError = () => {\n    if (!isMounted.current) return;\n\n    // Increment load attempts\n    loadAttempts.current += 1;\n\n    // If we've tried too many times, give up\n    if (loadAttempts.current > 3) {\n      console.log(`Too many load attempts for image ${imageId}, giving up`);\n      setError(true);\n      setLoading(false);\n      return;\n    }\n    console.log(`Image ${imageId} failed to load, attempt ${loadAttempts.current}`);\n\n    // Try fallback URL if we're not already using it\n    if (ipfsHash && imageSrc.includes(LOCAL_GATEWAY)) {\n      const urls = getIpfsUrl(ipfsHash, imageId);\n      console.log(`Switching to fallback URL for image ${imageId}`);\n      setImageSrc(urls.fallback);\n    } else {\n      // If we're already using the fallback URL or don't have an IPFS hash,\n      // try refreshing the image\n      console.log(`All URLs failed for image ${imageId}, trying refresh`);\n      if (onRefresh) {\n        onRefresh();\n      }\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(\"img\", {\n    ref: imageRef,\n    id: id,\n    src: imageSrc,\n    alt: alt,\n    style: style,\n    onError: handleError\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 164,\n    columnNumber: 5\n  }, this);\n};\n_s(ImageWithAuth, \"0LGzK6mxpU6D391UYqpEceMCZ8Y=\");\n_c = ImageWithAuth;\nexport default ImageWithAuth;\nvar _c;\n$RefreshReg$(_c, \"ImageWithAuth\");","map":{"version":3,"names":["React","useState","useEffect","useRef","api","normalizeIpfsHash","jsxDEV","_jsxDEV","LOCAL_GATEWAY","getIpfsUrl","hash","imageId","normalizedHash","localUrl","backendUrl","primary","fallback","ImageWithAuth","id","ipfsHash","alt","style","onRefresh","setLoading","isMounted","_s","imageSrc","setImageSrc","error","setError","imageRef","loadAttempts","loadImage","current","response","get","responseType","objectUrl","URL","createObjectURL","data","revokeObjectURL","err","console","urls","cleanupFunction","loadAndSetupCleanup","cleanup","handleError","log","includes","ref","src","onError","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Erwachens/Desktop/MyProject/frontend/src/components/images/ImageWithAuth.jsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\r\nimport api from '../../api';\r\nimport { normalizeIpfsHash } from '../../util/ipfs';\r\n\r\n// Local IPFS gateway URL\r\nconst LOCAL_GATEWAY = 'http://127.0.0.1:8080/ipfs/';\r\n\r\n// Function to get IPFS URL from hash with multiple fallback options\r\nconst getIpfsUrl = (hash, imageId) => {\r\n  // First try to normalize the hash\r\n  const normalizedHash = normalizeIpfsHash(hash);\r\n  if (!normalizedHash) return '';\r\n  \r\n  // Primary URL: Local gateway\r\n  const localUrl = `${LOCAL_GATEWAY}${normalizedHash}`;\r\n  \r\n  // Fallback URL: Direct backend download endpoint\r\n  const backendUrl = `/api/images/download-file/${imageId}/`;\r\n  \r\n  // Return both URLs for fallback mechanism\r\n  return {\r\n    primary: localUrl,\r\n    fallback: backendUrl\r\n  };\r\n};\r\n\r\n/**\r\n * Component for loading images with authentication\r\n * Uses axios interceptors to handle token refresh automatically\r\n */\r\nconst ImageWithAuth = ({ \r\n  id, \r\n  imageId, \r\n  ipfsHash, \r\n  alt, \r\n  style, \r\n  onRefresh, \r\n  setLoading,\r\n  isMounted \r\n}) => {\r\n  const [imageSrc, setImageSrc] = useState('');\r\n  const [error, setError] = useState(false);\r\n  const imageRef = useRef(null);\r\n  const loadAttempts = useRef(0);\r\n  \r\n  // Load the image using authenticated API request\r\n  const loadImage = async () => {\r\n    if (!isMounted.current) return;\r\n    \r\n    try {\r\n      setLoading(true);\r\n      setError(false);\r\n      \r\n      // Use axios with interceptors to handle authentication\r\n      // Remove cache-busting parameter to prevent request loops\r\n      const response = await api.get(`/api/images/download-file/${imageId}/`, {\r\n        responseType: 'blob'\r\n      });\r\n      \r\n      if (!isMounted.current) return;\r\n      \r\n      // Create an object URL from the blob\r\n      const objectUrl = URL.createObjectURL(response.data);\r\n      setImageSrc(objectUrl);\r\n      \r\n      // Clean up the object URL when the component unmounts or when the src changes\r\n      return () => {\r\n        URL.revokeObjectURL(objectUrl);\r\n      };\r\n    } catch (err) {\r\n      if (!isMounted.current) return;\r\n      \r\n      console.error(`Error loading image ${imageId}:`, err);\r\n      setError(true);\r\n      \r\n      // Try fallback URL if available\r\n      if (ipfsHash) {\r\n        const urls = getIpfsUrl(ipfsHash, imageId);\r\n        setImageSrc(urls.primary);\r\n      }\r\n    } finally {\r\n      if (isMounted.current) {\r\n        setLoading(false);\r\n      }\r\n    }\r\n  };\r\n  \r\n  // Load the image on mount and when imageId changes\r\n  useEffect(() => {\r\n    loadAttempts.current = 0;\r\n    \r\n    // Track if component is mounted\r\n    isMounted.current = true;\r\n    \r\n    // Create a variable to store the cleanup function\r\n    let cleanupFunction = null;\r\n    \r\n    const loadAndSetupCleanup = async () => {\r\n      try {\r\n        // Call loadImage and store the cleanup function\r\n        const cleanup = await loadImage();\r\n        \r\n        // Only store the cleanup if component is still mounted\r\n        if (isMounted.current && typeof cleanup === 'function') {\r\n          cleanupFunction = cleanup;\r\n        }\r\n      } catch (err) {\r\n        console.error('Error in loadImage:', err);\r\n      }\r\n    };\r\n    \r\n    // Start the loading process\r\n    loadAndSetupCleanup();\r\n    \r\n    // Clean up function\r\n    return () => {\r\n      // Mark component as unmounted\r\n      isMounted.current = false;\r\n      \r\n      // Call the cleanup function if it exists\r\n      if (typeof cleanupFunction === 'function') {\r\n        try {\r\n          cleanupFunction();\r\n        } catch (err) {\r\n          console.error('Error in cleanup function:', err);\r\n        }\r\n      }\r\n    };\r\n  }, [imageId]);\r\n  \r\n  // Handle image load error\r\n  const handleError = () => {\r\n    if (!isMounted.current) return;\r\n    \r\n    // Increment load attempts\r\n    loadAttempts.current += 1;\r\n    \r\n    // If we've tried too many times, give up\r\n    if (loadAttempts.current > 3) {\r\n      console.log(`Too many load attempts for image ${imageId}, giving up`);\r\n      setError(true);\r\n      setLoading(false);\r\n      return;\r\n    }\r\n    \r\n    console.log(`Image ${imageId} failed to load, attempt ${loadAttempts.current}`);\r\n    \r\n    // Try fallback URL if we're not already using it\r\n    if (ipfsHash && imageSrc.includes(LOCAL_GATEWAY)) {\r\n      const urls = getIpfsUrl(ipfsHash, imageId);\r\n      console.log(`Switching to fallback URL for image ${imageId}`);\r\n      setImageSrc(urls.fallback);\r\n    } else {\r\n      // If we're already using the fallback URL or don't have an IPFS hash,\r\n      // try refreshing the image\r\n      console.log(`All URLs failed for image ${imageId}, trying refresh`);\r\n      if (onRefresh) {\r\n        onRefresh();\r\n      }\r\n    }\r\n  };\r\n  \r\n  return (\r\n    <img\r\n      ref={imageRef}\r\n      id={id}\r\n      src={imageSrc}\r\n      alt={alt}\r\n      style={style}\r\n      onError={handleError}\r\n    />\r\n  );\r\n};\r\n\r\nexport default ImageWithAuth;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}