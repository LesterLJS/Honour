{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Erwachens\\\\Desktop\\\\MyProject\\\\frontend\\\\src\\\\context\\\\ImageContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useCallback } from 'react';\nimport { uploadImage as apiUploadImage, getMyImages as apiGetMyImages, getImageDownloadLink as apiGetImageDownloadLink, downloadImageFile as apiDownloadImageFile, searchSimilarImages as apiSearchSimilarImages, getAllImages as apiGetAllImages, deleteImage as apiDeleteImage, batchUploadImages as apiBatchUploadImages, pinAllImages as apiPinAllImages, pinImage as apiPinImage, unpinImage as apiUnpinImage, runGarbageCollection as apiRunGarbageCollection, runSelectiveGarbageCollection as apiRunSelectiveGarbageCollection, getIPFSPinStats as apiGetIPFSPinStats } from '../api/images';\n\n// Create the context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ImageContext = /*#__PURE__*/createContext(null);\n\n// Custom hook to use the image context\nexport const useImages = () => {\n  _s();\n  return useContext(ImageContext);\n};\n_s(useImages, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport const ImageProvider = ({\n  children\n}) => {\n  _s2();\n  const [myImages, setMyImages] = useState([]);\n  const [allImages, setAllImages] = useState([]);\n  const [searchResults, setSearchResults] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [pagination, setPagination] = useState({\n    currentPage: 1,\n    totalPages: 1,\n    totalImages: 0,\n    pageSize: 9,\n    hasNext: false,\n    hasPrevious: false\n  });\n\n  // Upload an image\n  const uploadImage = async imageFile => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiUploadImage(imageFile);\n      // Add the new image to the myImages array\n      setMyImages(prevImages => [response.data, ...prevImages]);\n      return response.data;\n    } catch (err) {\n      var _err$response, _err$response$data;\n      setError(((_err$response = err.response) === null || _err$response === void 0 ? void 0 : (_err$response$data = _err$response.data) === null || _err$response$data === void 0 ? void 0 : _err$response$data.error) || 'Image upload failed');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Batch upload multiple images\n  const batchUploadImages = async imageFiles => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiBatchUploadImages(imageFiles);\n\n      // Refresh the images list to include the newly uploaded images\n      await getMyImages();\n      return response.data;\n    } catch (err) {\n      var _err$response2, _err$response2$data;\n      setError(((_err$response2 = err.response) === null || _err$response2 === void 0 ? void 0 : (_err$response2$data = _err$response2.data) === null || _err$response2$data === void 0 ? void 0 : _err$response2$data.error) || 'Batch image upload failed');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Get user's images with pagination\n  const getMyImages = async (page = 1, pageSize = 9) => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiGetMyImages({\n        page,\n        page_size: pageSize\n      });\n\n      // The response now contains both results and pagination info\n      const {\n        results,\n        pagination: paginationData\n      } = response.data;\n\n      // Update state with the images and pagination info\n      setMyImages(results);\n      setPagination({\n        currentPage: paginationData.current_page,\n        totalPages: paginationData.total_pages,\n        totalImages: paginationData.total_images,\n        pageSize: paginationData.page_size,\n        hasNext: paginationData.has_next,\n        hasPrevious: paginationData.has_previous\n      });\n      return response.data;\n    } catch (err) {\n      var _err$response3, _err$response3$data;\n      setError(((_err$response3 = err.response) === null || _err$response3 === void 0 ? void 0 : (_err$response3$data = _err$response3.data) === null || _err$response3$data === void 0 ? void 0 : _err$response3$data.error) || 'Failed to fetch images');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Navigate to next page\n  const nextPage = useCallback(() => {\n    if (pagination.hasNext) {\n      getMyImages(pagination.currentPage + 1, pagination.pageSize);\n    }\n  }, [pagination]);\n\n  // Navigate to previous page\n  const previousPage = useCallback(() => {\n    if (pagination.hasPrevious) {\n      getMyImages(pagination.currentPage - 1, pagination.pageSize);\n    }\n  }, [pagination]);\n\n  // Go to a specific page\n  const goToPage = useCallback(page => {\n    if (page >= 1 && page <= pagination.totalPages) {\n      getMyImages(page, pagination.pageSize);\n    }\n  }, [pagination]);\n\n  // Get IPFS download link\n  const getImageDownloadLink = async imageId => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiGetImageDownloadLink(imageId);\n\n      // If the image is not pinned, try to pin it\n      if (response.data && !response.data.isPinned) {\n        console.log(`Image ${imageId} is not pinned, attempting to pin it...`);\n        try {\n          // Try to pin the image\n          await pinImage(imageId);\n          console.log(`Successfully pinned image ${imageId}`);\n\n          // Get the download link again to get updated pin status\n          const updatedResponse = await apiGetImageDownloadLink(imageId);\n          return updatedResponse;\n        } catch (pinError) {\n          console.error(`Error pinning image ${imageId}:`, pinError);\n          // Continue with the original response even if pinning failed\n        }\n      }\n\n      // Return the full response with all URLs and blockchain data\n      return response;\n    } catch (err) {\n      var _err$response4, _err$response4$data;\n      setError(((_err$response4 = err.response) === null || _err$response4 === void 0 ? void 0 : (_err$response4$data = _err$response4.data) === null || _err$response4$data === void 0 ? void 0 : _err$response4$data.error) || 'Failed to get download link');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Directly download image file from IPFS through the backend\n  const downloadImageFile = async imageId => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiDownloadImageFile(imageId);\n\n      // If we got a blob response, create an object URL for it\n      if (response.blob) {\n        const objectUrl = URL.createObjectURL(response.blob);\n        return {\n          success: true,\n          objectUrl,\n          contentType: response.contentType,\n          blob: response.blob\n        };\n      }\n      // If we got a URL fallback\n      else if (response.url) {\n        return {\n          success: true,\n          url: response.url,\n          hash: response.hash\n        };\n      }\n      // If we got an error\n      else {\n        setError(response.error || 'Failed to download image');\n        return {\n          success: false,\n          error: response.error || 'Failed to download image'\n        };\n      }\n    } catch (err) {\n      var _err$response5, _err$response5$data;\n      const errorMsg = ((_err$response5 = err.response) === null || _err$response5 === void 0 ? void 0 : (_err$response5$data = _err$response5.data) === null || _err$response5$data === void 0 ? void 0 : _err$response5$data.error) || 'Failed to download image';\n      setError(errorMsg);\n      return {\n        success: false,\n        error: errorMsg\n      };\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Search for similar images\n  const searchSimilarImages = async imageFile => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiSearchSimilarImages(imageFile);\n      setSearchResults(response.data);\n      return response.data;\n    } catch (err) {\n      var _err$response6, _err$response6$data;\n      setError(((_err$response6 = err.response) === null || _err$response6 === void 0 ? void 0 : (_err$response6$data = _err$response6.data) === null || _err$response6$data === void 0 ? void 0 : _err$response6$data.error) || 'Image search failed');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Admin: Get all images\n  const getAllImages = async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiGetAllImages();\n      setAllImages(response.data);\n      return response.data;\n    } catch (err) {\n      var _err$response7, _err$response7$data;\n      setError(((_err$response7 = err.response) === null || _err$response7 === void 0 ? void 0 : (_err$response7$data = _err$response7.data) === null || _err$response7$data === void 0 ? void 0 : _err$response7$data.error) || 'Failed to fetch all images');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Admin: Delete an image\n  const deleteImage = async imageId => {\n    setLoading(true);\n    setError(null);\n    try {\n      await apiDeleteImage(imageId);\n      // Remove the deleted image from state\n      setAllImages(prevImages => prevImages.filter(img => img.id !== imageId));\n      setMyImages(prevImages => prevImages.filter(img => img.id !== imageId));\n      return true;\n    } catch (err) {\n      var _err$response8, _err$response8$data;\n      setError(((_err$response8 = err.response) === null || _err$response8 === void 0 ? void 0 : (_err$response8$data = _err$response8.data) === null || _err$response8$data === void 0 ? void 0 : _err$response8$data.error) || 'Failed to delete image');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Pin all images uploaded by the current user\n  const pinAllImages = async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiPinAllImages();\n      return response.data;\n    } catch (err) {\n      var _err$response9, _err$response9$data;\n      setError(((_err$response9 = err.response) === null || _err$response9 === void 0 ? void 0 : (_err$response9$data = _err$response9.data) === null || _err$response9$data === void 0 ? void 0 : _err$response9$data.error) || 'Failed to pin images');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Pin a specific image\n  const pinImage = async imageId => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiPinImage(imageId);\n      // Update the image in the state to reflect it's now pinned\n      setMyImages(prevImages => prevImages.map(img => img.id === imageId ? {\n        ...img,\n        is_pinned: true\n      } : img));\n      setAllImages(prevImages => prevImages.map(img => img.id === imageId ? {\n        ...img,\n        is_pinned: true\n      } : img));\n      return response.data;\n    } catch (err) {\n      var _err$response10, _err$response10$data;\n      setError(((_err$response10 = err.response) === null || _err$response10 === void 0 ? void 0 : (_err$response10$data = _err$response10.data) === null || _err$response10$data === void 0 ? void 0 : _err$response10$data.error) || 'Failed to pin image');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Unpin a specific image (admin only)\n  const unpinImage = async imageId => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiUnpinImage(imageId);\n      // Update the image in the state to reflect it's now unpinned\n      setMyImages(prevImages => prevImages.map(img => img.id === imageId ? {\n        ...img,\n        is_pinned: false\n      } : img));\n      setAllImages(prevImages => prevImages.map(img => img.id === imageId ? {\n        ...img,\n        is_pinned: false\n      } : img));\n      return response.data;\n    } catch (err) {\n      var _err$response11, _err$response11$data;\n      setError(((_err$response11 = err.response) === null || _err$response11 === void 0 ? void 0 : (_err$response11$data = _err$response11.data) === null || _err$response11$data === void 0 ? void 0 : _err$response11$data.error) || 'Failed to unpin image');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Run selective IPFS garbage collection (admin only)\n  const runSelectiveGarbageCollection = async params => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiRunSelectiveGarbageCollection(params);\n      return response.data;\n    } catch (err) {\n      var _err$response12, _err$response12$data;\n      setError(((_err$response12 = err.response) === null || _err$response12 === void 0 ? void 0 : (_err$response12$data = _err$response12.data) === null || _err$response12$data === void 0 ? void 0 : _err$response12$data.error) || 'Failed to run selective garbage collection');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Get IPFS pin statistics (admin only)\n  const getIPFSPinStats = async (params = {}) => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiGetIPFSPinStats(params);\n      return response.data;\n    } catch (err) {\n      var _err$response13, _err$response13$data;\n      setError(((_err$response13 = err.response) === null || _err$response13 === void 0 ? void 0 : (_err$response13$data = _err$response13.data) === null || _err$response13$data === void 0 ? void 0 : _err$response13$data.error) || 'Failed to get IPFS pin statistics');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Run IPFS garbage collection (admin only)\n  const runGarbageCollection = async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await apiRunGarbageCollection();\n      return response.data;\n    } catch (err) {\n      var _err$response14, _err$response14$data;\n      setError(((_err$response14 = err.response) === null || _err$response14 === void 0 ? void 0 : (_err$response14$data = _err$response14.data) === null || _err$response14$data === void 0 ? void 0 : _err$response14$data.error) || 'Failed to run garbage collection');\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Context value\n  const value = {\n    myImages,\n    allImages,\n    searchResults,\n    loading,\n    error,\n    pagination,\n    uploadImage,\n    batchUploadImages,\n    getMyImages,\n    getImageDownloadLink,\n    downloadImageFile,\n    searchSimilarImages,\n    getAllImages,\n    deleteImage,\n    pinAllImages,\n    pinImage,\n    unpinImage,\n    runGarbageCollection,\n    runSelectiveGarbageCollection,\n    getIPFSPinStats,\n    nextPage,\n    previousPage,\n    goToPage\n  };\n  return /*#__PURE__*/_jsxDEV(ImageContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 396,\n    columnNumber: 10\n  }, this);\n};\n_s2(ImageProvider, \"e40L9L7C6/gY69RXf5xVGtqucuA=\");\n_c = ImageProvider;\nexport default ImageContext;\nvar _c;\n$RefreshReg$(_c, \"ImageProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useCallback","uploadImage","apiUploadImage","getMyImages","apiGetMyImages","getImageDownloadLink","apiGetImageDownloadLink","downloadImageFile","apiDownloadImageFile","searchSimilarImages","apiSearchSimilarImages","getAllImages","apiGetAllImages","deleteImage","apiDeleteImage","batchUploadImages","apiBatchUploadImages","pinAllImages","apiPinAllImages","pinImage","apiPinImage","unpinImage","apiUnpinImage","runGarbageCollection","apiRunGarbageCollection","runSelectiveGarbageCollection","apiRunSelectiveGarbageCollection","getIPFSPinStats","apiGetIPFSPinStats","jsxDEV","_jsxDEV","ImageContext","useImages","_s","ImageProvider","children","_s2","myImages","setMyImages","allImages","setAllImages","searchResults","setSearchResults","loading","setLoading","error","setError","pagination","setPagination","currentPage","totalPages","totalImages","pageSize","hasNext","hasPrevious","imageFile","response","prevImages","data","err","_err$response","_err$response$data","imageFiles","_err$response2","_err$response2$data","page","page_size","results","paginationData","current_page","total_pages","total_images","has_next","has_previous","_err$response3","_err$response3$data","nextPage","previousPage","goToPage","imageId","isPinned","console","log","updatedResponse","pinError","_err$response4","_err$response4$data","blob","objectUrl","URL","createObjectURL","success","contentType","url","hash","_err$response5","_err$response5$data","errorMsg","_err$response6","_err$response6$data","_err$response7","_err$response7$data","filter","img","id","_err$response8","_err$response8$data","_err$response9","_err$response9$data","map","is_pinned","_err$response10","_err$response10$data","_err$response11","_err$response11$data","params","_err$response12","_err$response12$data","_err$response13","_err$response13$data","_err$response14","_err$response14$data","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Erwachens/Desktop/MyProject/frontend/src/context/ImageContext.jsx"],"sourcesContent":["import React, { createContext, useState, useContext, useCallback } from 'react';\r\nimport { \r\n  uploadImage as apiUploadImage,\r\n  getMyImages as apiGetMyImages,\r\n  getImageDownloadLink as apiGetImageDownloadLink,\r\n  downloadImageFile as apiDownloadImageFile,\r\n  searchSimilarImages as apiSearchSimilarImages,\r\n  getAllImages as apiGetAllImages,\r\n  deleteImage as apiDeleteImage,\r\n  batchUploadImages as apiBatchUploadImages,\r\n  pinAllImages as apiPinAllImages,\r\n  pinImage as apiPinImage,\r\n  unpinImage as apiUnpinImage,\r\n  runGarbageCollection as apiRunGarbageCollection,\r\n  runSelectiveGarbageCollection as apiRunSelectiveGarbageCollection,\r\n  getIPFSPinStats as apiGetIPFSPinStats\r\n} from '../api/images';\r\n\r\n// Create the context\r\nconst ImageContext = createContext(null);\r\n\r\n// Custom hook to use the image context\r\nexport const useImages = () => useContext(ImageContext);\r\n\r\nexport const ImageProvider = ({ children }) => {\r\n  const [myImages, setMyImages] = useState([]);\r\n  const [allImages, setAllImages] = useState([]);\r\n  const [searchResults, setSearchResults] = useState([]);\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n  const [pagination, setPagination] = useState({\r\n    currentPage: 1,\r\n    totalPages: 1,\r\n    totalImages: 0,\r\n    pageSize: 9,\r\n    hasNext: false,\r\n    hasPrevious: false\r\n  });\r\n\r\n  // Upload an image\r\n  const uploadImage = async (imageFile) => {\r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      const response = await apiUploadImage(imageFile);\r\n      // Add the new image to the myImages array\r\n      setMyImages(prevImages => [response.data, ...prevImages]);\r\n      return response.data;\r\n    } catch (err) {\r\n      setError(err.response?.data?.error || 'Image upload failed');\r\n      throw err;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Batch upload multiple images\r\n  const batchUploadImages = async (imageFiles) => {\r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      const response = await apiBatchUploadImages(imageFiles);\r\n      \r\n      // Refresh the images list to include the newly uploaded images\r\n      await getMyImages();\r\n      \r\n      return response.data;\r\n    } catch (err) {\r\n      setError(err.response?.data?.error || 'Batch image upload failed');\r\n      throw err;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Get user's images with pagination\r\n  const getMyImages = async (page = 1, pageSize = 9) => {\r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      const response = await apiGetMyImages({ page, page_size: pageSize });\r\n      \r\n      // The response now contains both results and pagination info\r\n      const { results, pagination: paginationData } = response.data;\r\n      \r\n      // Update state with the images and pagination info\r\n      setMyImages(results);\r\n      setPagination({\r\n        currentPage: paginationData.current_page,\r\n        totalPages: paginationData.total_pages,\r\n        totalImages: paginationData.total_images,\r\n        pageSize: paginationData.page_size,\r\n        hasNext: paginationData.has_next,\r\n        hasPrevious: paginationData.has_previous\r\n      });\r\n      \r\n      return response.data;\r\n    } catch (err) {\r\n      setError(err.response?.data?.error || 'Failed to fetch images');\r\n      throw err;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n  \r\n  // Navigate to next page\r\n  const nextPage = useCallback(() => {\r\n    if (pagination.hasNext) {\r\n      getMyImages(pagination.currentPage + 1, pagination.pageSize);\r\n    }\r\n  }, [pagination]);\r\n\r\n  // Navigate to previous page\r\n  const previousPage = useCallback(() => {\r\n    if (pagination.hasPrevious) {\r\n      getMyImages(pagination.currentPage - 1, pagination.pageSize);\r\n    }\r\n  }, [pagination]);\r\n\r\n  // Go to a specific page\r\n  const goToPage = useCallback((page) => {\r\n    if (page >= 1 && page <= pagination.totalPages) {\r\n      getMyImages(page, pagination.pageSize);\r\n    }\r\n  }, [pagination]);\r\n\r\n// Get IPFS download link\r\nconst getImageDownloadLink = async (imageId) => {\r\n  setLoading(true);\r\n  setError(null);\r\n  try {\r\n    const response = await apiGetImageDownloadLink(imageId);\r\n    \r\n    // If the image is not pinned, try to pin it\r\n    if (response.data && !response.data.isPinned) {\r\n      console.log(`Image ${imageId} is not pinned, attempting to pin it...`);\r\n      \r\n      try {\r\n        // Try to pin the image\r\n        await pinImage(imageId);\r\n        console.log(`Successfully pinned image ${imageId}`);\r\n        \r\n        // Get the download link again to get updated pin status\r\n        const updatedResponse = await apiGetImageDownloadLink(imageId);\r\n        return updatedResponse;\r\n      } catch (pinError) {\r\n        console.error(`Error pinning image ${imageId}:`, pinError);\r\n        // Continue with the original response even if pinning failed\r\n      }\r\n    }\r\n    \r\n    // Return the full response with all URLs and blockchain data\r\n    return response;\r\n  } catch (err) {\r\n    setError(err.response?.data?.error || 'Failed to get download link');\r\n    throw err;\r\n  } finally {\r\n    setLoading(false);\r\n  }\r\n};\r\n\r\n// Directly download image file from IPFS through the backend\r\nconst downloadImageFile = async (imageId) => {\r\n  setLoading(true);\r\n  setError(null);\r\n  try {\r\n    const response = await apiDownloadImageFile(imageId);\r\n    \r\n    // If we got a blob response, create an object URL for it\r\n    if (response.blob) {\r\n      const objectUrl = URL.createObjectURL(response.blob);\r\n      return {\r\n        success: true,\r\n        objectUrl,\r\n        contentType: response.contentType,\r\n        blob: response.blob\r\n      };\r\n    } \r\n    // If we got a URL fallback\r\n    else if (response.url) {\r\n      return {\r\n        success: true,\r\n        url: response.url,\r\n        hash: response.hash\r\n      };\r\n    }\r\n    // If we got an error\r\n    else {\r\n      setError(response.error || 'Failed to download image');\r\n      return {\r\n        success: false,\r\n        error: response.error || 'Failed to download image'\r\n      };\r\n    }\r\n  } catch (err) {\r\n    const errorMsg = err.response?.data?.error || 'Failed to download image';\r\n    setError(errorMsg);\r\n    return {\r\n      success: false,\r\n      error: errorMsg\r\n    };\r\n  } finally {\r\n    setLoading(false);\r\n  }\r\n};\r\n\r\n  // Search for similar images\r\n  const searchSimilarImages = async (imageFile) => {\r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      const response = await apiSearchSimilarImages(imageFile);\r\n      setSearchResults(response.data);\r\n      return response.data;\r\n    } catch (err) {\r\n      setError(err.response?.data?.error || 'Image search failed');\r\n      throw err;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Admin: Get all images\r\n  const getAllImages = async () => {\r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      const response = await apiGetAllImages();\r\n      setAllImages(response.data);\r\n      return response.data;\r\n    } catch (err) {\r\n      setError(err.response?.data?.error || 'Failed to fetch all images');\r\n      throw err;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Admin: Delete an image\r\n  const deleteImage = async (imageId) => {\r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      await apiDeleteImage(imageId);\r\n      // Remove the deleted image from state\r\n      setAllImages(prevImages => prevImages.filter(img => img.id !== imageId));\r\n      setMyImages(prevImages => prevImages.filter(img => img.id !== imageId));\r\n      return true;\r\n    } catch (err) {\r\n      setError(err.response?.data?.error || 'Failed to delete image');\r\n      throw err;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Pin all images uploaded by the current user\r\n  const pinAllImages = async () => {\r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      const response = await apiPinAllImages();\r\n      return response.data;\r\n    } catch (err) {\r\n      setError(err.response?.data?.error || 'Failed to pin images');\r\n      throw err;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Pin a specific image\r\n  const pinImage = async (imageId) => {\r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      const response = await apiPinImage(imageId);\r\n      // Update the image in the state to reflect it's now pinned\r\n      setMyImages(prevImages => \r\n        prevImages.map(img => \r\n          img.id === imageId ? { ...img, is_pinned: true } : img\r\n        )\r\n      );\r\n      setAllImages(prevImages => \r\n        prevImages.map(img => \r\n          img.id === imageId ? { ...img, is_pinned: true } : img\r\n        )\r\n      );\r\n      return response.data;\r\n    } catch (err) {\r\n      setError(err.response?.data?.error || 'Failed to pin image');\r\n      throw err;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Unpin a specific image (admin only)\r\n  const unpinImage = async (imageId) => {\r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      const response = await apiUnpinImage(imageId);\r\n      // Update the image in the state to reflect it's now unpinned\r\n      setMyImages(prevImages => \r\n        prevImages.map(img => \r\n          img.id === imageId ? { ...img, is_pinned: false } : img\r\n        )\r\n      );\r\n      setAllImages(prevImages => \r\n        prevImages.map(img => \r\n          img.id === imageId ? { ...img, is_pinned: false } : img\r\n        )\r\n      );\r\n      return response.data;\r\n    } catch (err) {\r\n      setError(err.response?.data?.error || 'Failed to unpin image');\r\n      throw err;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Run selective IPFS garbage collection (admin only)\r\n  const runSelectiveGarbageCollection = async (params) => {\r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      const response = await apiRunSelectiveGarbageCollection(params);\r\n      return response.data;\r\n    } catch (err) {\r\n      setError(err.response?.data?.error || 'Failed to run selective garbage collection');\r\n      throw err;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Get IPFS pin statistics (admin only)\r\n  const getIPFSPinStats = async (params = {}) => {\r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      const response = await apiGetIPFSPinStats(params);\r\n      return response.data;\r\n    } catch (err) {\r\n      setError(err.response?.data?.error || 'Failed to get IPFS pin statistics');\r\n      throw err;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Run IPFS garbage collection (admin only)\r\n  const runGarbageCollection = async () => {\r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      const response = await apiRunGarbageCollection();\r\n      return response.data;\r\n    } catch (err) {\r\n      setError(err.response?.data?.error || 'Failed to run garbage collection');\r\n      throw err;\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Context value\r\n  const value = {\r\n    myImages,\r\n    allImages,\r\n    searchResults,\r\n    loading,\r\n    error,\r\n    pagination,\r\n    uploadImage,\r\n    batchUploadImages,\r\n    getMyImages,\r\n    getImageDownloadLink,\r\n    downloadImageFile,\r\n    searchSimilarImages,\r\n    getAllImages,\r\n    deleteImage,\r\n    pinAllImages,\r\n    pinImage,\r\n    unpinImage,\r\n    runGarbageCollection,\r\n    runSelectiveGarbageCollection,\r\n    getIPFSPinStats,\r\n    nextPage,\r\n    previousPage,\r\n    goToPage\r\n  };\r\n\r\n  return <ImageContext.Provider value={value}>{children}</ImageContext.Provider>;\r\n};\r\n\r\nexport default ImageContext;\r\n\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}